<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/05/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>面向对象编程</title>
    <url>/2023/06/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="面向对象编程-基础"><a href="#面向对象编程-基础" class="headerlink" title="面向对象编程( 基础)"></a>面向对象编程( 基础)</h2><h3 id="1-Java语言的基本元素：类和对象"><a href="#1-Java语言的基本元素：类和对象" class="headerlink" title="1.Java语言的基本元素：类和对象"></a>1.Java语言的基本元素：类和对象</h3><p>类的定义使用关键字：class。格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类名&#123;</span><br><span class="line">	属性声明;</span><br><span class="line">    方法声明;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//声明属性age</span></span><br><span class="line">    <span class="type">int</span> age ;	                   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明方法showAge()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        </span><br><span class="line">	    System.out.println(<span class="string">&quot;人吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.对象的创建</p>
<ul>
<li>创建对象，使用关键字：<strong>new</strong></li>
<li>创建对象语法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1：给创建的对象命名</span></span><br><span class="line"><span class="comment">//把创建的对象用一个引用数据类型的变量保存起来，这样就可以反复使用这个对象了</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：</span></span><br><span class="line"><span class="keyword">new</span> 类名()<span class="comment">//也称为匿名对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonTest</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//创建Person类的对象</span></span><br><span class="line">		<span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		<span class="comment">//创建Dog类的对象</span></span><br><span class="line">		<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.对象调用属性或方法</p>
<ul>
<li><p>对象是类的一个<strong>实例</strong>，必然具备该类事物的属性和行为（即方法）。</p>
</li>
<li><p>使用”<code>对象名.属性</code>“ 或 “<code>对象名.方法</code>“的方式访问对象成员（包括属性和方法）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明Animal类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="comment">//动物类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> legs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Move.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">xb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        xb.legs = <span class="number">4</span>;<span class="comment">//访问属性</span></span><br><span class="line">        System.out.println(xb.legs);</span><br><span class="line">        xb.eat();<span class="comment">//访问方法</span></span><br><span class="line">        xb.move();<span class="comment">//访问方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名对象</p>
<ul>
<li>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。<ul>
<li>如：new Person().shout();</li>
</ul>
</li>
<li>使用情况<ul>
<li>如果一个对象只需要进行一次方法调用，那么就可以使用匿名对象。 </li>
<li>我们经常将匿名对象作为实参传递给一个方法调用。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ol>
<li>面向对象内容的三条主线：</li>
</ol>
<ul>
<li>Java类及类的成员：（重点）属性、方法、构造器；（熟悉）代码块、内部类</li>
<li>面向对象的特征：封装、继承、多态、（抽象）</li>
<li>其他关键字的使用：this、super、package、import、static、final、interface、abstract等</li>
</ul>
<ol start="2">
<li>面向过程编程(POP)  vs  面向对象编程(OOP)<br>2.1 简单的语言描述二者的区别</li>
</ol>
<blockquote>
<p>面向过程：<br>     - 以<code>函数</code>为组织单位。<br>     - 是一种“<code>执行者思维</code>”，适合解决简单问题。扩展能力差、后期维护难度较大。</p>
</blockquote>
<blockquote>
<p>面向对象：<br>      - 以<code>类</code>为组织单位。每种事物都具备自己的<code>属性</code>和<code>行为/功能</code>。<br>      - 是一种“<code>设计者思维</code>”，适合解决复杂问题。代码扩展性强、可维护性高。</p>
</blockquote>
<p>2.2 二者关系：<br>我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程！</p>
<ol start="3">
<li></li>
</ol>
<blockquote>
<p>面向对象编程的两个核心概念：类（Class）、对象（Object）<br>谈谈对这两个概念的理解？<br>类:具有相同特征的事物的抽象描述，是<code>抽象的</code>、概念上的定义。<br>对象：实际存在的该类事物的<code>每个个体</code>，是<code>具体的</code>，因而也称为<code>实例(instance)</code>。</p>
</blockquote>
<ol start="4">
<li>类的声明与使用<br>4.1 体会：设计类，其实就是设计类的成员<br>class Person{</li>
</ol>
<p>}</p>
<p>4.2 类的内部成员一、二：</p>
<p>成员之一：属性、成员变量、field（字段、域）<br>成员之二：（成员）方法、函数、method</p>
<p>4.3 类的实例化<br>等价描述：类的实例化 &lt;&#x3D;&gt; 创建类的对象  &lt;&#x3D;&gt; 创建类的实例<br>格式：类类型 对象名 &#x3D; 通过new创建的对象实体<br>举例：<br>Phone p1 &#x3D; new Phone();<br>Scanner scan &#x3D; new Scanner(System.in);<br>String str &#x3D; new String();</p>
<ol start="5">
<li>面向对象完成具体功能的操作的三步流程（非常重要）<br>步骤1：创建类，并设计类的内部成员（属性、方法）<br>步骤2：创建类的对象。比如：Phone p1 &#x3D; new Phone();<br>步骤3：通过对象，调用其内部声明的属性或方法，完成相关的功能</li>
</ol>
<h3 id="2-对象的内存解析"><a href="#2-对象的内存解析" class="headerlink" title="2.对象的内存解析"></a>2.对象的内存解析</h3><p>HotSpot Java虚拟机的架构图如下。其中我们主要关心的是运行时数据区部分（Runtime Data Area）。</p>
<p><img src="D:\Java入门教程\01_课件与电子教材\01_课件与电子教材\尚硅谷_第06章_面向对象编程（基础）\images\JVM架构-简图.png" alt="JVM架构-简图"></p>
<p>其中：</p>
<p><code>堆（Heap）</code>：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</p>
<p><code>栈（Stack）</code>：是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。 方法执行完，自动释放。</p>
<p><code>方法区（Method Area）</code>：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h3 id="3-2-对象内存解析"><a href="#3-2-对象内存解析" class="headerlink" title="3.2 对象内存解析"></a>3.2 对象内存解析</h3><h3 id="3-类的成员之一：成员变量-field"><a href="#3-类的成员之一：成员变量-field" class="headerlink" title="3.类的成员之一：成员变量(field)"></a>3.类的成员之一：成员变量(field)</h3><p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符<span class="number">1</span>] class 类名&#123;</span><br><span class="line">    [修饰符<span class="number">2</span>] 数据类型 成员变量名 [= 初始化值]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>位置要求：必须在类中，方法外</li>
<li>修饰符2(暂不考虑)<ul>
<li>常用的权限修饰符有：private、缺省、protected、public</li>
<li>其他修饰符：static、final</li>
</ul>
</li>
<li>数据类型<ul>
<li>任何基本数据类型(如int、Boolean) 或 任何引用数据类型。</li>
</ul>
</li>
<li>成员变量名<ul>
<li>属于标识符，符合命名规则和规范即可。</li>
</ul>
</li>
<li>初始化值<ul>
<li>根据情况，可以显式赋值；也可以不赋值，使用默认值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;             <span class="comment">//声明private变量 age</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> “Lila”;    <span class="comment">//声明public变量 name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员变量 vs 局部变量</p>
<p><strong>1、变量的分类：成员变量与局部变量</strong></p>
<ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部等位置声明的变量称为局部变量</li>
</ul>
<p><img src="C:\Users\ieerc\AppData\Roaming\Typora\typora-user-images\image-20230602085927195.png" alt="image-20230602085927195"></p>
<p>成员变量 与 局部变量 的对比</p>
<ul>
<li><p>相同点</p>
<ul>
<li>变量声明的格式相同： 数据类型  变量名 &#x3D; 初始化值</li>
</ul>
<ul>
<li><pre><code>        变量必须先声明、后初始化、再使用。
</code></pre>
</li>
</ul>
<ul>
<li>变量都有其对应的作用域。只在其作用域内是有效的</li>
</ul>
</li>
<li><p>不同点</p>
</li>
</ul>
<p>1、声明位置和方式<br>（1）实例变量：在类中方法外<br>（2）局部变量：在方法体{}中或方法的形参列表、代码块中</p>
<p>2、在内存中存储的位置不同<br>（1）实例变量：堆<br>（2）局部变量：栈</p>
<p>3、生命周期<br>（1）实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被GC回收而消亡，<br>            而且每一个对象的实例变量是独立的。<br>（2）局部变量：和方法调用的生命周期一样，每一次方法被调用而在存在，随着方法执行的结束而消亡，<br>            而且每一次方法调用都是独立。</p>
<p>4、作用域<br>（1）实例变量：通过对象就可以使用，本类中直接调用，其他类中“对象.实例变量”<br>（2）局部变量：出了作用域就不能使用</p>
<p>5、修饰符（后面来讲）<br>（1）实例变量：public,protected,private,final,volatile,transient等<br>（2）局部变量：final</p>
<p>6、默认值<br>（1）实例变量：有默认值<br>（2）局部变量：没有，必须手动初始化。其中的形参比较特殊，靠实参给它初始化。</p>
<p>对象属性的默认初始化赋值</p>
<p>当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。</p>
<p><img src="C:\Users\ieerc\AppData\Roaming\Typora\typora-user-images\image-20230602090032264.png" alt="image-20230602090032264"></p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;<span class="comment">//人类</span></span><br><span class="line">    <span class="comment">//1.属性</span></span><br><span class="line">    String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//年龄</span></span><br><span class="line">    <span class="type">boolean</span> isMale;<span class="comment">//是否是男性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String nation)</span> &#123;</span><br><span class="line">        <span class="comment">//nation:局部变量</span></span><br><span class="line">        String color;<span class="comment">//color:局部变量</span></span><br><span class="line">        color = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.show(<span class="string">&quot;CHN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>类的成员之一：属性</p>
<p>1.变量的分类：</p>
<ul>
<li>角度一：按照数据类型来分：基本数据类型（8种）、引用数据类型（数组、类、接口、枚举、注解、记录）</li>
<li>角度二：按照变量在类中声明的位置的不同：成员变量（或属性）、局部变量（方法内、方法形参、构造器内、构造器形参、代码块内等）</li>
</ul>
<ol start="2">
<li><p>属性的几个称谓：成员变量、属性、field（字段、域）</p>
</li>
<li><p>区分成员变量   vs 局部变量<br>3.1 相同点：</p>
</li>
</ol>
<blockquote>
<p>变量声明的格式相同：数据类型 变量名 &#x3D; 变量值<br>变量都有其有效的作用域。出了作用域，就失效了。<br>变量必须先声明，后赋值，再使用。</p>
</blockquote>
<p>3.2 不同点：<br>① 类中声明的位置的不同：<br>    属性：声明在类内，方法外的变量<br>    局部变量：声明方法、构造器内部的变量</p>
<p>② 在内存中分配的位置不同（难）：<br>    属性：随着对象的创建，存储在堆空间中。<br>    局部变量：存储在栈空间中</p>
<p>③ 生命周期：<br>    属性：随着对象的创建而创建，随着对象的消亡而消亡。<br>    局部变量：随着方法对应的栈帧入栈，局部变量会在栈中分配；随着方法对应的栈帧出栈，局部变量消亡。</p>
<p>④ 作用域：<br>    属性：在整个类的内部都是有效的<br>    局部变量：仅限于声明此局部变量所在的方法（或构造器、代码块）中</p>
<p>⑤ 是否可以有权限修饰符进行修饰：(难)<br>    都有哪些权限修饰符：public、protected、缺省、private。（用于表明所修饰的结构可调用的范围的大小）</p>
<pre><code>属性，是可以使用权限修饰符进行修饰的。 暂时还未讲封装性，所以大家先不用写任何权限符。
而局部变量，不能使用任何权限修饰符进行修饰的。
</code></pre>
<p>⑥ 是否有默认值：(重点)<br>    属性:都有默认初始化值<br>        意味着，如果没有给属性进行显式初始化赋值，则会有默认初始化值。</p>
<pre><code>局部变量：都没有默认初始化值。
    意味着，在使用局部变量之前，必须要显式的赋值，否则报错。

    注意：对于方法的形参而言，在调用方法时，给此形参赋值即可。
</code></pre>
<h3 id="4-类的成员之二：方法-method"><a href="#4-类的成员之二：方法-method" class="headerlink" title="4.类的成员之二：方法(method)"></a>4.类的成员之二：方法(method)</h3><ul>
<li><code>方法</code>是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为<code>函数</code>或<code>过程</code>。 </li>
<li>将功能封装为方法的目的是，可以<code>实现代码重用，减少冗余，简化代码</code></li>
<li>Java里的方法<code>不能独立存在</code>，所有的方法必须定义在类里。</li>
</ul>
<p>声明方法的语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名([形参列表])[<span class="keyword">throws</span> 异常列表]&#123;</span><br><span class="line">        方法体的功能代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）一个完整的方法 &#x3D; 方法头 + 方法体。</p>
<ul>
<li>方法头就是<code>[修饰符] 返回值类型 方法名([形参列表])[throws 异常列表]</code>，也称为<code>方法签名</code>。通常调用方法时只需要关注方法头就可以，从方法头可以看出这个方法的功能和调用格式。</li>
<li>方法体就是方法被调用后要执行的代码。对于调用者来说，不了解方法体如何实现的，并不影响方法的使用。</li>
</ul>
<p><strong>（2）方法头可能包含5个部分</strong></p>
<ul>
<li><p><strong>修饰符</strong>：可选的。方法的修饰符也有很多，例如：public、protected、private、static、abstract、native、final、synchronized等，后面会一一学习。</p>
<ul>
<li>其中，权限修饰符有public、protected、private。在讲封装性之前，我们先默认使用pulbic修饰方法。</li>
<li>其中，根据是否有static，可以将方法分为静态方法和非静态方法。其中静态方法又称为类方法，非静态方法又称为实例方法。咱们在讲static前先学习实例方法。</li>
</ul>
</li>
<li><p><strong>返回值类型</strong>： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者。</p>
<ul>
<li>无返回值，则声明：void</li>
<li>有返回值，则声明出返回值类型（可以是任意类型）。与方法体中“<code>return 返回值</code>”搭配使用</li>
</ul>
</li>
<li><p><strong>方法名</strong>：属于标识符，命名时遵循标识符命名规则和规范，“见名知意”</p>
</li>
<li><p><strong>形参列表</strong>：表示完成方法体功能时需要外部提供的数据列表。可以包含零个，一个或多个参数。</p>
<ul>
<li>无论是否有参数，()不能省略</li>
<li>如果有参数，每一个参数都要指定数据类型和参数名，多个参数之间使用逗号分隔，例如：<ul>
<li>一个参数： (数据类型  参数名)</li>
<li>二个参数： (数据类型1  参数1,  数据类型2  参数2)</li>
</ul>
</li>
<li>参数的类型可以是基本数据类型、引用数据类型</li>
</ul>
</li>
<li><p><strong>throws 异常列表</strong>：可选，在【第09章-异常处理】章节再讲</p>
</li>
</ul>
<p><strong>（3）方法体</strong>：方法体必须有{}括起来，在{}中编写完成方法功能的代码</p>
<p><strong>（4）关于方法体中return语句的说明：</strong></p>
<ul>
<li><p>return语句的作用是结束方法的执行，并将方法的结果返回去</p>
</li>
<li><p>如果返回值类型不是void，方法体中必须保证一定有 return 返回值; 语句，并且要求该返回值结果的类型与声明的返回值类型一致或兼容。</p>
</li>
<li><p>如果返回值类型为void时，方法体中可以没有return语句，如果要用return语句提前结束方法的执行，那么return后面不能跟返回值，直接写return ; 就可以。</p>
</li>
<li><p>return语句后面就不能再写其他代码了，否则会报错：Unreachable code</p>
</li>
</ul>
<p>补充：方法的分类：按照是否有形参及返回值</p>
<img src="C:\Users\ieerc\AppData\Roaming\Typora\typora-user-images\image-20230602090647628.png" alt="image-20230602090647628" style="zoom: 67%;" />

<p>方法调用语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象.方法名([实参列表])</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test04.method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法调用案例演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInvokeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">MethodDefineDemo</span> <span class="variable">md</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodDefineDemo</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------方法调用演示-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用MethodDefineDemo类中无参无返回值的方法sayHello</span></span><br><span class="line">        md.sayHello();</span><br><span class="line">        md.sayHello();</span><br><span class="line">        md.sayHello();</span><br><span class="line">        <span class="comment">//调用一次，执行一次，不调用不执行</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//调用MethodDefineDemo类中有参无返回值的方法printRectangle</span></span><br><span class="line">        md.printRectangle(<span class="number">5</span>,<span class="number">10</span>,<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//调用MethodDefineDemo类中无参有返回值的方法getIntBetweenOneToHundred</span></span><br><span class="line">        md.getIntBetweenOneToHundred();<span class="comment">//语法没问题，就是结果丢失</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> md.getIntBetweenOneToHundred();</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line"></span><br><span class="line">        System.out.println(md.getIntBetweenOneToHundred());</span><br><span class="line">        <span class="comment">//上面的代码调用了getIntBetweenOneToHundred三次，这个方法执行了三次</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//调用MethodDefineDemo类中有参有返回值的方法max</span></span><br><span class="line">        md.max(<span class="number">3</span>,<span class="number">6</span>);<span class="comment">//语法没问题，就是结果丢失</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">bigger</span> <span class="operator">=</span> md.max(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bigger = &quot;</span> + bigger);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;8,3中较大者是：&quot;</span> + md.max(<span class="number">8</span>,<span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建Scanner的对象</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//System.in默认代表键盘输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、提示输入xx</span></span><br><span class="line">System.out.print(<span class="string">&quot;请输入一个整数：&quot;</span>); <span class="comment">//对象.非静态方法(实参列表)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、接收输入内容</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> input.nextInt();  <span class="comment">//对象.非静态方法()</span></span><br></pre></td></tr></table></figure>

<p>使用的注意点</p>
<p>   (1）必须先声明后使用，且方法必须定义在类的内部</p>
<p>（2）调用一次就执行一次，不调用不执行。</p>
<p>（3）方法中可以调用类中的方法或属性，不可以在方法内部定义方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    方法<span class="number">2</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字return的使用</p>
<ul>
<li>return在方法中的作用：<ul>
<li>作用1：结束一个方法</li>
<li>作用2：结束一个方法的同时，可以返回数据给方法的调用者</li>
</ul>
</li>
<li>注意点：在return关键字的直接后面不能声明执行语句</li>
</ul>
<p>方法调用内存分析</p>
<p>总结：</p>
<p>类的成员之二：方法(method)</p>
<ol>
<li>使用方法的好处</li>
</ol>
<p>方法的理解：<code>方法</code>是类或对象行为特征的抽象，用来完成某个功能操作。<br>方法的好处：实现代码重用，减少冗余，简化代码</p>
<ol start="2">
<li>使用举例</li>
</ol>
<ul>
<li>Math.random()的random()方法</li>
<li>Math.sqrt(x)的sqrt(x)方法</li>
<li>System.out.println(x)的println(x)方法</li>
<li>new Scanner(System.in).nextInt()的nextInt()方法</li>
<li>Arrays类中的binarySearch()方法、sort()方法、equals()方法</li>
</ul>
<ol start="3">
<li><p>声明举例<br>public void eat()<br>public void sleep(int hour)<br>public String interests(String hobby)<br>public int getAge()</p>
</li>
<li><p>方法声明的格式 (重要)</p>
</li>
</ol>
<p>权限修饰符 [其它修饰符] 返回值类型 方法名(形参列表) [throws 异常类型]{ &#x2F;&#x2F;方法头<br>    &#x2F;&#x2F;方法体<br>}</p>
<p>注：[]中的内部不是必须的，以后再讲。</p>
<ol start="5">
<li>具体的方法声明的细节</li>
</ol>
<p>5.1 权限修饰符<br>    ① Java规定了哪些权限修饰符呢？ 有四种：private \ 缺省 \ protected \ public (放到封装性讲)<br>       暂时大家声明方法时，可以先都写成public的。</p>
<p>5.2 返回值类型：描述当调用完此方法时，是否需要返回一个结果。<br>       分类：<br>       &gt; 无返回值类型：使用void表示即可。比如：System.out.println(x)的println(x)方法、Arrays的sort()<br>       &gt; 有具体的返回值类型：需要指明返回的数据的类型。可以是基本数据类型，也可以引用数据类型<br>            &gt; 需要在方法内部配合使用”return + 返回值类型的变量或常量”<br>           比如：Math.random()、new Scanner(System.in).nextInt()等<br>       [经验]我们在声明方法时，要不要提供返回值类型呢？<br>          &gt; 根据方法具体实现的功能来决定。换句话说，具体问题具体分析<br>          &gt; 根据题目要求</p>
<p>5.3 方法名：属于标识符。需要满足标识符的规定和规范。“见名知意”</p>
<p>5.4 形参列表：形参，属于局部变量，且可以声明多个。<br>           格式：(形参类型1 形参1,形参类型2 形参2,…)<br>           分类：无形参列表 、 有形参列表<br>              &gt; 无形参列表：不能省略一对()。比如：Math.random()、new Scanner(System.in).nextInt()<br>              &gt; 有形参列表：根据方法调用时，需要的不确定的变量的类型和个数，确定形参的类型和个数。<br>                          比如：Arrays类中的binarySearch()方法、sort()方法、equals()方法</p>
<pre><code>        [经验]我们在声明方法时，是否需要形参列表呢？
            &gt; 根据方法具体实现的功能来决定。换句话说，具体问题具体分析
            &gt; 根据题目要求
</code></pre>
<p>5.5 方法体： 当我们调用一个方法时，真正执行的代码。体现了此方法的功能。</p>
<ol start="6">
<li>注意点</li>
</ol>
<blockquote>
<p>Java里的方法<code>不能独立存在</code>，所有的方法必须定义在类里。<br>Java中的方法不调用，不执行。每调用一次，就执行一次。<br>方法内可以调用本类中的(其它)方法或属性<br>方法内不能定义方法。</p>
</blockquote>
<p>7.关键字：return<br>7.1 return的作用<br>    - 作用1：结束一个方法<br>    - 作用2：结束一个方法的同时，可以返回数据给方法的调用者 (方法声明中如果有返回值类型，则方法内需要搭配return使用）</p>
<p>7.2 使用注意点：<br>    return后面不能声明执行语句。</p>
<ol start="8">
<li>方法调用的内存解析：</li>
</ol>
<ul>
<li>形参：方法在声明时，一对()内声明的一个或多个形式参数，简称为形参。</li>
<li>实参：方法在被调用时，实际传递给形参的变量或常量，就称为实际参数，简称实参。</li>
</ul>
<p>过程概述：</p>
<h3 id="5-对象数组"><a href="#5-对象数组" class="headerlink" title="5.对象数组"></a>5.对象数组</h3><h2 id="6-对象数组"><a href="#6-对象数组" class="headerlink" title="6. 对象数组"></a>6. 对象数组</h2><p>数组的元素可以是基本数据类型，也可以是引用数据类型。当元素是引用类型中的类时，我们称为对象数组。</p>
<p><strong>1、案例</strong></p>
<p>定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。</p>
<p>问题一：打印出3年级(state值为3）的学生信息。</p>
<p>问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</p>
<p>提示：</p>
<ol>
<li><p>生成随机数：Math.random()，返回值类型double; </p>
</li>
<li><p>四舍五入取整：Math.round(double d)，返回值类型long。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> number;<span class="comment">//学号</span></span><br><span class="line">	<span class="type">int</span> state;<span class="comment">//年级</span></span><br><span class="line">	<span class="type">int</span> score;<span class="comment">//成绩</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;number : &quot;</span> + number </span><br><span class="line">				+ <span class="string">&quot;,state : &quot;</span> + state + <span class="string">&quot;,score : &quot;</span> + score);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Student s1 = new Student();</span></span><br><span class="line">		<span class="comment">// s1.number = 1;</span></span><br><span class="line">		<span class="comment">// s1.state = (int)(Math.random() * 6 + 1);//[1,6]</span></span><br><span class="line">		<span class="comment">// s1.score = (int)(Math.random() * 101);//[0,100]</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Student s2 = new Student();</span></span><br><span class="line">		<span class="comment">// s2.number = 2;</span></span><br><span class="line">		<span class="comment">// s2.state = (int)(Math.random() * 6 + 1);//[1,6]</span></span><br><span class="line">		<span class="comment">// s2.score = (int)(Math.random() * 101);//[0,100]</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// //....</span></span><br><span class="line">		<span class="comment">// 对象数组</span></span><br><span class="line">		<span class="comment">// String[] arr = new String[10];</span></span><br><span class="line">		<span class="comment">// 数组的创建</span></span><br><span class="line">		Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">20</span>];</span><br><span class="line">		<span class="comment">// 通过循环结构给数组的属性赋值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line">			<span class="comment">// 数组元素的赋值</span></span><br><span class="line">			students[i] = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">			<span class="comment">// 数组元素是一个对象，给对象的各个属性赋值</span></span><br><span class="line">			students[i].number = (i + <span class="number">1</span>);</span><br><span class="line">			students[i].state = (<span class="type">int</span>) (Math.random() * <span class="number">6</span> + <span class="number">1</span>);<span class="comment">// [1,6]</span></span><br><span class="line">			students[i].score = (<span class="type">int</span>) (Math.random() * <span class="number">101</span>);<span class="comment">// [0,100]</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (students[i].state == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">//				System.out.println(</span></span><br><span class="line"><span class="comment">//						&quot;number:&quot; + students[i].number + &quot;,state:&quot; + students[i].state + &quot;,score:&quot; + students[i].score);</span></span><br><span class="line">				students[i].info();</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line">		<span class="comment">// 问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line">		<span class="comment">// 排序前</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line"><span class="comment">//			System.out.println(</span></span><br><span class="line"><span class="comment">//					&quot;number:&quot; + students[i].number + &quot;,state:&quot; + </span></span><br><span class="line"><span class="comment">//							students[i].state + &quot;,score:&quot; + students[i].score);</span></span><br><span class="line">			</span><br><span class="line">			students[i].info();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="comment">// 排序：</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; students.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (students[j].score &gt; students[j + <span class="number">1</span>].score) &#123;</span><br><span class="line">					<span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> students[j];</span><br><span class="line">					students[j] = students[j + <span class="number">1</span>];</span><br><span class="line">					students[j + <span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 排序后：</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line"><span class="comment">//			System.out.println(</span></span><br><span class="line"><span class="comment">//					&quot;number:&quot; + students[i].number + &quot;,state:&quot; + </span></span><br><span class="line"><span class="comment">//							students[i].state + &quot;,score:&quot; + students[i].score);</span></span><br><span class="line">			</span><br><span class="line">			students[i].info();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存解析：</p>
<p><img src="D:\Java入门教程\01_课件与电子教材\01_课件与电子教材\尚硅谷_第06章_面向对象编程（基础）\images\image-20220320001627445.png" alt="image-20220320001627445"></p>
<p><strong>2、注意点</strong></p>
<p>对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，如果不创建，数组的元素的默认值就是<code>null</code>，所以很容易出现<code>空指针异常NullPointerException</code>。</p>
<h3 id="6-再谈方法"><a href="#6-再谈方法" class="headerlink" title="6.再谈方法"></a>6.再谈方法</h3><p>方法的重载概念：</p>
<ul>
<li><strong>方法重载</strong>：在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可。<ul>
<li>参数列表不同，意味着参数个数或参数类型的不同</li>
</ul>
</li>
<li><strong>重载的特点</strong>：与修饰符、返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</li>
<li><strong>重载方法调用</strong>：JVM通过方法的参数列表，调用匹配的方法。<ul>
<li>先找个数、类型最匹配的</li>
<li>再找个数和类型可以兼容的，如果同时多个方法可以兼容将会报错</li>
</ul>
</li>
</ul>
<p>总结：</p>
<p>再谈方法之1：方法的重载(overload)</p>
<ol>
<li><p>定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可。<br>满足这样特征的多个方法，彼此之间构成方法的重载。</p>
</li>
<li><p>总结为：“两同一不同”<br>两同：同一个类、相同的方法名<br>一不同：参数列表不同。① 参数个数不同 ② 参数类型不同</p>
<p>注意：方法的重载与形参的名、权限修饰符、返回值类型都没有关系。</p>
</li>
<li><p>举例<br>Arrays类中sort(xxx[] arr)、binarySearch(xxx[] arr,xxx)、equals(xxx[] ,yyy[])</p>
</li>
<li><p>如何判断两个方法是相同的呢？（换句话说，编译器是如何确定调用的某个具体的方法呢？）</p>
</li>
</ol>
<p>如何判断两个方法是相同的呢？ 方法名相同，且形参列表相同。（形参列表相同指的是参数个数和类型都相同，与形参名没关系）</p>
<p>要求：在一个类中，允许存在多个相同名字的方法，只要他们的形参列表不同即可。</p>
<p>编译器是如何确定调用的某个具体的方法呢？先通过方法名确定了一波重载的方法，进而通过不同的形参列表，确定具体的某一个方法。</p>
<ol start="5">
<li>在同一个类中不允许定义两个相同的方法。</li>
</ol>
<p>方法的参数传递机制</p>
<p>7.3.1 形参和实参</p>
<ul>
<li>形参（formal parameter）：在定义方法时，方法名后面括号()中声明的变量称为形式参数，简称形参。</li>
<li>实参（actual parameter）：在调用方法时，方法名后面括号()中的使用的值&#x2F;变量&#x2F;表达式称为实际参数，简称实参。</li>
</ul>
<p>7.3.2 参数传递机制：值传递</p>
<p>Java里方法的参数传递方式只有一种：<code>值传递</code>。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。</p>
<ul>
<li><p>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</p>
</li>
<li><p>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</p>
</li>
</ul>
<p>总结：</p>
<p>再谈方法之2：可变个数形参的方法(jdk5.0)</p>
<ol>
<li><p>使用场景<br>在调用方法时，可能会出现方法形参的类型是确定的，但是参数的个数不确定。此时，我们就可以使用可变个数形参的方法</p>
</li>
<li><p>格式：(参数类型 … 参数名)</p>
</li>
<li><p>说明：<br>① 可变个数形参的方法在调用时，针对于可变的形参赋的实参的个数可以为：0个、1个或多个<br>② 可变个数形参的方法与同一个类中，同名的多个方法之间可以构成重载<br>③ 特例：可变个数形参的方法与同一个类中方法名相同，且与可变个数形参的类型相同的数组参数不构成重载。<br>④ 可变个数的形参必须声明在形参列表的最后<br>⑤ 可变个数的形参最多在一个方法的形参列表中出现一次</p>
</li>
</ol>
<p>再谈方法之3：方法的值传递机制</p>
<ol>
<li><p>（复习）对于方法内声明的局部变量来说：如果出现赋值操作</p>
<blockquote>
<p>如果是基本数据类型的变量，则将此变量保存的数据值传递出去。<br>如果是引用数据类型的变量，则将此变量保存的地址值传递出去。</p>
</blockquote>
</li>
<li><p>方法的参数的传递机制：值传递机制</p>
</li>
</ol>
<p>2.1 概念（复习）<br>形参：在定义方法时，方法名后面括号()中声明的变量称为形式参数，简称形参。<br>实参：在调用方法时，方法名后面括号()中的使用的值&#x2F;变量&#x2F;表达式称为实际参数，简称实参。</p>
<p>2.2 规则：实参给形参赋值的过程<br>    &gt; 如果形参是基本数据类型的变量，则将实参保存的数据值赋给形参。<br>    &gt; 如果形参是引用数据类型的变量，则将实参保存的地址值赋给形参。</p>
<ol start="3">
<li>面试题：Java中的参数传递机制是什么？值传递。（不是引用传递）</li>
</ol>
<p>递归(recursion)方法</p>
<p><strong>递归方法调用</strong>：方法自己调用自己的现象就称为递归。</p>
<p>**递归的分类:**直接递归、间接递归。</p>
<p>直接递归：方法自身调用自己。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">	methodA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>间接递归：可以理解为A()方法调用B()方法，B()方法调用C()方法，C()方法调用A()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">	B();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">	C();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">	A();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ul>
<li>递归方法包含了一种<code>隐式的循环</code>。</li>
<li>递归方法会<code>重复执行</code>某段代码，但这种重复执行无须循环控制。</li>
<li>递归一定要向<code>已知方向</code>递归，否则这种递归就变成了无穷递归，停不下来，类似于<code>死循环</code>。最终发生<code>栈内存溢出</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RecursionDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RecursionDemo</span>();</span><br><span class="line">		<span class="comment">//计算1~num的和，使用递归完成</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      	<span class="comment">// 调用求和的方法</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> demo.getSum(num);</span><br><span class="line">      	<span class="comment">// 输出结果</span></span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	  通过递归算法实现.</span></span><br><span class="line"><span class="comment">  	  参数列表:int </span></span><br><span class="line"><span class="comment">  	  返回值类型: int </span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">      	<span class="comment">/* </span></span><br><span class="line"><span class="comment">      	   num为1时,方法返回1,</span></span><br><span class="line"><span class="comment">      	   相当于是方法的出口,num总有是1的情况</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">		<span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          num不为1时,方法返回 num +(num-1)的累和</span></span><br><span class="line"><span class="comment">          递归调用getSum方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="keyword">return</span> num + getSum(num-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\ieerc\AppData\Roaming\Typora\typora-user-images\image-20230602092505371.png" alt="image-20230602092505371"></p>
<p>总结：</p>
<p>再谈方法之4：递归方法</p>
<ol>
<li><p>何为递归方法？方法自己调用自己的现象就称为递归。</p>
</li>
<li><p>递归方法分类：直接递归、间接递归</p>
</li>
<li><p>使用说明：</p>
</li>
</ol>
<ul>
<li>递归方法包含了一种<code>隐式的循环</code>。</li>
<li>递归方法会<code>重复执行</code>某段代码，但这种重复执行无须循环控制。</li>
<li>递归一定要向<code>已知方向</code>递归，否则这种递归就变成了无穷递归，停不下来，类似于<code>死循环</code>。最终发生<code>栈内存溢出</code>。</li>
</ul>
<p>注意：</p>
<ol>
<li>递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环<code>慢的多</code>，<br>所以在使用递归时要慎重。</li>
<li>在要求高性能的情况下尽量避免使用递归，递归调用既花时间又<code>耗内存</code>。考虑使用循环迭代</li>
</ol>
<h3 id="7-关键字：package、import"><a href="#7-关键字：package、import" class="headerlink" title="7.关键字：package、import"></a>7.关键字：package、import</h3><p>package，称为包，用于指明该文件中定义的类、接口等结构所在的包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 顶层包名.子包名 ;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pack1.pack2;    <span class="comment">//指定类PackageTest属于包pack1.pack2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageTest</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;in  method display()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>一个源文件只能有一个声明包的package语句</li>
<li>package语句作为Java源文件的第一条语句出现。若缺省该语句，则指定为无名包。</li>
<li>包名，属于标识符，满足标识符命名的规则和规范（全部小写）、见名知意<ul>
<li>包通常使用所在公司域名的倒置：com.atguigu.xxx。</li>
<li>大家取包名时不要使用”<code>java.xx</code>“包</li>
</ul>
</li>
<li>包对应于文件系统的目录，package语句中用 “.” 来指明包(目录)的层次，每.一次就表示一层文件目录。</li>
<li>同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）。不同的包下可以定义同名的结构（类、接口）</li>
</ul>
<p>8.1.2 包的作用</p>
<ul>
<li>包可以包含类和子包，划分<code>项目层次</code>，便于管理</li>
<li>帮助<code>管理大型软件</code>系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式</li>
<li>解决<code>类命名冲突</code>的问题</li>
<li>控制<code>访问权限</code></li>
</ul>
<p>8.1.4 JDK中主要的包介绍</p>
<p><code>java.lang</code>—-包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能<br><code>java.net</code>—-包含执行与网络相关的操作的类和接口。<br><code>java.io</code>   —-包含能提供多种输入&#x2F;输出功能的类。<br><code>java.util</code>—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。<br><code>java.text</code>—-包含了一些java格式化相关的类<br><code>java.sql</code>—-包含了java进行JDBC数据库编程的相关类&#x2F;接口<br><code>java.awt</code>—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。  </p>
<p>import(导入)</p>
<p>为了使用定义在其它包中的Java类，需用import语句来显式引入指定包下所需要的类。相当于<code>import语句告诉编译器到哪里去寻找这个类</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import 包名.类名;</span><br></pre></td></tr></table></figure>

<p>8.2.3 注意事项</p>
<ul>
<li>import语句，声明在包的声明和类的声明之间。</li>
<li>如果需要导入多个类或接口，那么就并列显式多个import语句即可</li>
<li>如果使用<code>a.*</code>导入结构，表示可以导入a包下的所有的结构。举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。</li>
<li>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。</li>
<li>如果已经导入java.a包下的类，那么如果需要使用a包的子包下的类的话，仍然需要导入。</li>
<li>如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类。</li>
<li>（了解）<code>import static</code>组合的使用：调用指定类或接口下的静态的属性或方法</li>
</ul>
<p>总结：</p>
<p>一、package关键字的使用</p>
<ol>
<li>说明</li>
</ol>
<ul>
<li>package:包</li>
<li>package用于指明该文件中定义的类、接口等结构所在的包</li>
<li>一个源文件只能有一个声明包的package语句</li>
<li>package语句作为Java源文件的第一条语句出现。若缺省该语句，则指定为无名包。</li>
<li>包名，属于标识符，满足标识符命名的规则和规范（全部小写）、见名知意<ul>
<li>包通常使用所在公司域名的倒置：com.atguigu.xxx。</li>
<li>大家取包名时不要使用”<code>java.xx</code>“包</li>
</ul>
</li>
<li>包对应于文件系统的目录，package语句中用 “.” 来指明包(目录)的层次，每.一次就表示一层文件目录。</li>
<li>同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）。不同的包下可以定义同名的结构（类、接口）</li>
</ul>
<ol start="2">
<li>包的作用</li>
</ol>
<ul>
<li>包可以包含类和子包，划分<code>项目层次</code>，便于管理</li>
<li>帮助<code>管理大型软件</code>系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式</li>
<li>解决<code>类命名冲突</code>的问题</li>
<li>控制<code>访问权限</code></li>
</ul>
<ol start="3">
<li>JDK中主要的包</li>
</ol>
<p><code>java.lang</code>—-包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能<br><code>java.net</code>—-包含执行与网络相关的操作的类和接口。<br><code>java.io</code>   —-包含能提供多种输入&#x2F;输出功能的类。<br><code>java.util</code>—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。<br><code>java.text</code>—-包含了一些java格式化相关的类<br><code>java.sql</code>—-包含了java进行JDBC数据库编程的相关类&#x2F;接口<br><code>java.awt</code>—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。</p>
<p>二、import关键字的使用</p>
<ul>
<li>import : 导入</li>
<li>import语句来显式引入指定包下所需要的类。相当于<code>import语句告诉编译器到哪里去寻找这个类</code>。</li>
<li>import语句，声明在包的声明和类的声明之间。</li>
<li>如果需要导入多个类或接口，那么就并列显式多个import语句即可</li>
<li>如果使用<code>a.*</code>导入结构，表示可以导入a包下的所有的结构。举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。</li>
<li>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。</li>
<li>如果已经导入java.a包下的类，那么如果需要使用a包的子包下的类的话，仍然需要导入。</li>
<li>如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类。</li>
<li>（了解）<code>import static</code>组合的使用：调用指定类或接口下的静态的属性或方法</li>
</ul>
<p>面向对象特征一：封装性(encapsulation)</p>
<p>所谓封装，就是把客观事物封装成抽象概念的类，并且类可以把自己的数据和方法只向可信的类或者对象开放，向没必要开放的类或者对象隐藏信息。</p>
<p>通俗的讲，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p>
<p>Java如何实现数据封装</p>
<ul>
<li><p>实现封装就是控制类或成员的可见性范围。这就需要依赖访问控制修饰符，也称为权限修饰符来控制。</p>
</li>
<li><p>权限修饰符：<code>public</code>、<code>protected</code>、<code>缺省</code>、<code>private</code>。具体访问范围如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>本类内部</th>
<th>本包内</th>
<th>其他包的子类</th>
<th>其他包非子类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>缺省</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>具体修饰的结构：</p>
<ul>
<li>外部类：public、缺省</li>
<li>成员变量、成员方法、构造器、成员内部类：public、protected、缺省、private</li>
</ul>
<img src="C:\Users\ieerc\AppData\Roaming\Typora\typora-user-images\image-20230602093711659.png" alt="image-20230602093711659" style="zoom: 67%;" />

<p>封装性的体现</p>
<p>成员变量&#x2F;属性私有化</p>
<p>概述：私有化类的成员变量，提供公共的get和set方法，对外暴露获取和修改属性的功能。</p>
<p>实现步骤：</p>
<p><strong>①</strong> 使用 <code>private</code> 修饰成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> 数据类型 变量名 ；</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> marry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>②</strong> 提供 <code>getXxx</code>方法 &#x2F; <code>setXxx</code> 方法，可以访问成员变量，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> marry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String n)</span> &#123;</span><br><span class="line">		name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMarry</span><span class="params">(<span class="type">boolean</span> m)</span>&#123;</span><br><span class="line">        marry = m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMarry</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>成员变量封装的好处：</strong></p>
<ul>
<li>让使用者只能通过事先预定的方法来<code>访问数据</code>，从而可以在该方法里面加入控制逻辑，限制对成员变量的不合理访问。还可以进行数据检查，从而有利于保证对象信息的完整性。</li>
<li><code>便于修改</code>，提高代码的可维护性。主要说的是隐藏的部分，在内部修改了，如果其对外可以的访问方式不变的话，外部根本感觉不到它的修改。例如：Java8-&gt;Java9，String从char[]转为byte[]内部实现，而对外的方法不变，我们使用者根本感觉不到它内部的修改。</li>
</ul>
<p>总结：</p>
<p>面向对象特征之一：封装性</p>
<ol>
<li>为什么需要封装性？<br>理论上：<br>-<code>高内聚</code>：类的内部数据操作细节自己完成，不允许外部干涉；<br>-<code>低耦合</code>：仅暴露少量的方法给外部使用，尽量方便外部调用。</li>
</ol>
<p>通俗的说：把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p>
<ol start="2">
<li>如何实现数据封装？</li>
</ol>
<p>2.1 权限修饰符<br>    Java规定了4种权限修饰，分别是：private、缺省、protected、public</p>
<p>2.2 作用<br>    我们可以使用4种权限修饰来修饰类及类的内部成员。当这些成员被调用时，体现可见性的大小。</p>
<p>2.3 实际案例：<br>在题目中，我们给Animal的对象的legs属性赋值。在实际的常识中，我们知道legs不能赋值为负数的。但是如果<br>直接调用属性legs，是不能加入判断逻辑的。那怎么办呢？</p>
<blockquote>
<p>将legs属性私有化(private)，禁止在Animal类的外部直接调用此属性<br>提供给legs属性赋值的setLegs()方法，在此方法中加入legs赋值的判断逻辑if(legs &gt;&#x3D; 0 &amp;&amp; legs % 2 &#x3D;&#x3D;0)<br>将此方法暴露出去，使得在Animal类的外部调用此方法，对legs属性赋值。<br>提供给legs属性获取的getLegs()方法，此方法对外暴露。使得在Animal类的外部还可以调用此属性的值。</p>
</blockquote>
<p>2.4 4种权限具体使用<br>《见课件》</p>
<blockquote>
<p>类：只能使用public、缺省修饰<br>类的内部成员：可以使用4种权限修饰进行修饰。</p>
</blockquote>
<p>2.5 开发中4种权限使用频率的情况：<br>   比较高：public、private<br>   比较低：缺省、protected</p>
<ol start="3">
<li>封装性的体现</li>
</ol>
<blockquote>
<p>场景1：私有化(private)类的属性，提供公共(public)的get和set方法，对此属性进行获取或修改<br>场景2：将类中不需要对外暴露的方法，设置为private.<br>场景3：单例模式中构造器private的了，避免在类的外部创建实例。（放到static关键字后讲）</p>
</blockquote>
<h3 id="8-类的成员之三：构造器-Constructor"><a href="#8-类的成员之三：构造器-Constructor" class="headerlink" title="8.类的成员之三：构造器(Constructor)"></a>8.类的成员之三：构造器(Constructor)</h3><p>构造器的作用</p>
<p>new对象，并在new对象的时候为实例变量赋值。</p>
<p>举例：Person p &#x3D; new <code>Person(“Peter”,15)</code>;</p>
<p>构造器的语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类名&#123;</span><br><span class="line">    [修饰符] 构造器名()&#123;</span><br><span class="line">    	<span class="comment">// 实例初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    [修饰符] 构造器名(参数列表)&#123;</span><br><span class="line">        <span class="comment">// 实例初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>构造器名必须与它所在的类名必须相同。</li>
<li>它没有返回值，所以不需要返回值类型，也不需要void。</li>
<li>构造器的修饰符只能是权限修饰符，不能被其他任何修饰。比如，不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值。</li>
</ol>
<p>总结：</p>
<p>类的成员之三：构造器（constructor），构造方法</p>
<ol>
<li>构造器的理解</li>
</ol>
<p>constructor ：n. 建设者、建造者<br>construct：v. 建设、建造、创造<br>construction： n. 建设、建造   CCB</p>
<ol start="2">
<li><p>构造器的作用<br>作用1：搭配new关键字，创建类的对象<br>作用2：在创建对象的同时，可以给对象的相关属性赋值</p>
</li>
<li><p>构造器的使用说明</p>
</li>
</ol>
<blockquote>
<p>构造器声明的格式：权限修饰符 类名(形参列表){}<br>创建类以后，在没有显示提供任何构造器的情况下，系统会默认提供一个空参的构造器，且构造器的权限<br>与类声明的权限相同。<br>一旦类中显示声明了构造器，则系统不再提供默认的空参的构造器。<br>一个类中可以声明多个构造器，彼此之间构成重载。</p>
</blockquote>
<h3 id="9-阶段性知识补充"><a href="#9-阶段性知识补充" class="headerlink" title="9.阶段性知识补充"></a>9.阶段性知识补充</h3><p>一、类中属性（当前仅考虑实例变量）赋值过程：</p>
<ol>
<li>在类的属性中，可以有哪些位置给属性赋值？<br>① 默认初始化；<br>② 显式初始化；<br>③ 构造器中初始化；</li>
</ol>
<hr>
<p>④ 通过”对象.方法”的方式赋值；<br>⑤ 通过”对象.属性”的方式赋值；</p>
<ol start="2">
<li><p>这些位置执行的先后顺序是怎样？<br>① - ② - ③ - ④&#x2F;⑤</p>
</li>
<li><p>以上操作在对象创建过程中可以执行的次数如何？</p>
</li>
</ol>
<blockquote>
<p>只能执行一次：①、②、③<br>可以多次执行：④、⑤</p>
</blockquote>
<p>二、JavaBean的理解</p>
<p>所谓JavaBean，是指符合如下标准的Java类：</p>
<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ul>
<p>三、读懂UML类图</p>
<h2 id="面向对象编程-进阶"><a href="#面向对象编程-进阶" class="headerlink" title="面向对象编程(进阶)"></a>面向对象编程(进阶)</h2><h3 id="1-关键字：this"><a href="#1-关键字：this" class="headerlink" title="1.关键字：this"></a>1.关键字：this</h3><ul>
<li><p>在Java中，this关键字不算难理解，它的作用和其词义很接近。</p>
<ul>
<li>它在方法（准确的说是实例方法或非static的方法）内部使用，表示调用该方法的对象</li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象。</li>
</ul>
</li>
<li><p>this可以调用的结构：成员变量、方法和构造器</p>
</li>
</ul>
<p>什么时候使用this</p>
<p>实例方法或构造器中使用当前对象的成员</p>
<p>在实例方法或构造器中，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的可读性。不过，通常我们都习惯省略this。</p>
<p>但是，当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量。即：我们可以用this来区分<code>成员变量</code>和<code>局部变量</code>。比如：</p>
<img src="C:\Users\ieerc\AppData\Roaming\Typora\typora-user-images\image-20230602101347354.png" alt="image-20230602101347354" style="zoom:67%;" />

<p> 同一个类中构造器互相调用</p>
<p>this可以作为一个类中构造器相互调用的特殊格式。</p>
<ul>
<li>this()：调用本类的无参构造器</li>
<li>this(实参列表)：调用本类的有参构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        this(&quot;&quot;,18);//调用本类有参构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();<span class="comment">//调用本类无参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(name);<span class="comment">//调用本类中有一个String参数的构造器</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name +<span class="string">&quot;，年龄：&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>不能出现递归调用。比如，调用自身构造器。<ul>
<li>推论：如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)”</li>
</ul>
</li>
<li>this()和this(实参列表)只能声明在构造器首行。<ul>
<li>推论：在类的一个构造器中，最多只能声明一个”this(参数列表)”</li>
</ul>
</li>
</ul>
<p>总结：</p>
<p>this关键字的使用</p>
<ol>
<li>目前可能出现的问题？及解决方案？</li>
</ol>
<p>我们在声明一个属性对应的setXxx方法时，通过形参给对应的属性赋值。如果形参名和属性名同名了，那么该如何在<br>方法内区分这两个变量呢？</p>
<p>解决方案：使用this。具体来讲，使用this修饰的变量，表示的是属性。没有用this修饰的，表示的是形参。</p>
<ol start="2">
<li><p>this可以调用的结构：成员变量、方法、构造器</p>
</li>
<li><p>this的理解：当前对象（在方法中调用时） 或 当前正在创建的对象（在构造器中调用时）</p>
</li>
</ol>
<p>4.1 this调用属性和方法</p>
<p>【针对于方法内的使用情况：（准确的说是非static修饰的方法）】</p>
<p>一般情况：我们通过对象a调用方法，可以在方法内调用当前对象a的属性或其他方法。此时，我们可以在属性和其他方法前<br>使用”this.”，表示当前属性或方法所属的对象a。但是，一般情况下，我们都选择省略此”this.”结构。<br>特殊情况：如果方法的形参与对象的属性同名了，我们必须使用”this.”进行区分。使用this.修饰的变量即为属性（或成员变量），<br>没有使用this.修饰的变量，即为局部变量。</p>
<p>【针对于构造器内的使用情况：】<br>一般情况：我们通过构造器创建对象时，可以在构造器内调用当前正在创建的对象的属性或方法。此时，我们可以在属性和方法前<br>使用”this.”，表示当前属性或方法所属的对象。但是，一般情况下，我们都选择省略此”this.”结构。<br>特殊情况：如果构造器的形参与正在创建的对象的属性同名了，我们必须使用”this.”进行区分。使用this.修饰的变量即为<br>属性（或成员变量），没有使用this.修饰的变量，即为局部变量。</p>
<p>4.2 this调用构造器</p>
<blockquote>
<p>格式：”this(形参列表)”<br>我们可以在类的构造器中，调用当前类中指定的其它构造器<br>要求：”this(形参列表)”必须声明在当前构造器的首行<br>结论：”this(形参列表)”在构造器中最多声明一个<br>如果一个类中声明了n个构造器，则最多有n-1个构造器可以声明有”this(形参列表)”的结构</p>
</blockquote>
<h3 id="2-面向对象特征二：继承-Inheritance"><a href="#2-面向对象特征二：继承-Inheritance" class="headerlink" title="2.面向对象特征二：继承(Inheritance)"></a>2.面向对象特征二：继承(Inheritance)</h3><p>继承的好处：</p>
<ul>
<li><p>继承的出现减少了代码冗余，提高了代码的复用性。</p>
</li>
<li><p>继承的出现，更有利于功能的扩展。</p>
</li>
<li><p>继承的出现让类与类之间产生了<code>is-a</code>的关系，为多态的使用提供了前提。</p>
<ul>
<li>继承描述事物之间的所属关系，这种关系是：<code>is-a</code> 的关系。可见，父类更通用、更一般，子类更具体。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：不要仅为了获取其他类中某个功能而去继承！</p>
</blockquote>
<p>继承的语法</p>
<p>2.2.1 继承中的语法格式</p>
<p>通过 <code>extends</code> 关键字，可以声明一个类B继承另外一个类A，定义格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类A &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[修饰符] class 类B extends 类A &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承中的基本概念</p>
<p>类B，称为子类、派生类(derived class)、SubClass</p>
<p>类A，称为父类、超类、基类(base class)、SuperClass</p>
<p>继承性的细节说明</p>
<p>、子类会继承父类所有的实例变量和实例方法**</p>
<p>从类的定义来看，类是一类具有相同特性的事物的抽象描述。父类是所有子类共同特征的抽象描述。而实例变量和实例方法就是事物的特征，那么父类中声明的实例变量和实例方法代表子类事物也有这个特征。</p>
<ul>
<li>当子类对象被创建时，在堆中给对象申请内存时，就要看子类和父类都声明了什么实例变量，这些实例变量都要分配内存。</li>
<li>当子类对象调用方法时，编译器会先在子类模板中看该类是否有这个方法，如果没找到，会看它的父类甚至父类的父类是否声明了这个方法，遵循<code>从下往上</code>找的顺序，找到了就停止，一直到根父类都没有找到，就会报编译错误。</li>
</ul>
<p>所以继承意味着子类的对象除了看子类的类模板还要看父类的类模板。</p>
<p>子类不能直接访问父类中私有的(private)的成员变量和方法</p>
<p>子类虽会继承父类私有(private)的成员变量，但子类不能对继承的私有成员变量直接进行访问，可通过继承的get&#x2F;set方法进行访问。如图所示：</p>
<p><strong>3、在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”</strong></p>
<p>子类在继承父类以后，还可以定义自己特有的方法，这就可以看做是对父类功能上的扩展。</p>
<p><strong>4、Java支持多层继承(继承体系)</strong></p>
<img src="C:\Users\ieerc\AppData\Roaming\Typora\typora-user-images\image-20230602102420138.png" alt="image-20230602102420138" style="zoom: 67%;" />

<p>说明：</p>
<ul>
<li><p>子类和父类是一种相对的概念</p>
</li>
<li><p>顶层父类是Object类。所有的类默认继承Object，作为父类。</p>
</li>
</ul>
<p>5、一个父类可以同时拥有多个子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Java只支持单继承，不支持多重继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>面向对象特征之二：继承性</p>
<ol>
<li>继承性的理解</li>
</ol>
<blockquote>
<p>生活上：财产的继承、颜值的继承<br>代码层面：<br>自上而下：定义了一个类A，在定义另一个类B时，发现类B的功能与类A相似，考虑类B继承于类A<br>自下而上：定义了类B,C,D等，发现B、C、D有类似的属性和方法，则可以考虑将相同的属性和方法进行抽取，<br>    封装到类A中，让类B、C、D继承于类A,同时，B、C、D中的相似的功能就可以删除了。</p>
</blockquote>
<ol start="2">
<li>继承性的好处</li>
</ol>
<ul>
<li>继承的出现减少了代码冗余，提高了代码的复用性。</li>
<li>继承的出现，更有利于功能的扩展。</li>
<li>继承的出现让类与类之间产生了<code>is-a</code>的关系，为多态的使用提供了前提。<ul>
<li>继承描述事物之间的所属关系，这种关系是：<code>is-a</code> 的关系。可见，父类更通用、更一般，子类更具体。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>继承的格式：</li>
</ol>
<p>class A{<br>    &#x2F;&#x2F;属性、方法<br>}</p>
<p>class B extends A{</p>
<p>}</p>
<p>继承中的基本概念：</p>
<p>类A: 父类、superClass、超类、基类<br>类B: 子类、subClass、派生类</p>
<ol start="4">
<li>有了继承性以后：</li>
</ol>
<blockquote>
<p>子类就获取到了父类中声明的所有的属性和方法。<br>但是，由于封装性的影响，可能子类不能直接调用父类中声明的属性或方法。<br>子类在继承父类以后，还可以扩展自己特有的功能（体现：增加特有的属性、方法）<br>extends:延展、扩展、延伸<br>子类和父类的理解，要区别于集合和子集<br>不要为了继承而继承。在继承之前，判断一下是否有is a的关系。</p>
</blockquote>
<ol start="5">
<li><p>默认的父类：<br>Java中声明的类，如果没有显式的声明其父类时，则默认继承于java.lang.Object</p>
</li>
<li><p>补充说明：</p>
</li>
</ol>
<blockquote>
<p>Java是支持多层继承。<br>概念：直接父类、间接父类<br>Java中的子父类的概念是相对的。<br>Java中一个父类可以声明多个子类。反之，一个子类只能有一个父类（Java的单继承性）</p>
</blockquote>
<h3 id="3-方法的重写（override-x2F-overwrite）"><a href="#3-方法的重写（override-x2F-overwrite）" class="headerlink" title="3.方法的重写（override&#x2F;overwrite）"></a>3.方法的重写（override&#x2F;overwrite）</h3><p>父类的所有方法子类都会继承，但是当某个方法被继承到子类之后，子类觉得父类原来的实现不适合于自己当前的类，该怎么办呢？子类可以对从父类中继承来的方法进行改造，我们称为方法的<code>重写 (override、overwrite)</code>。也称为方法的<code>重置</code>、<code>覆盖</code>。</p>
<p>在程序执行时，子类的方法将覆盖父类的方法。</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来电显示号码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SmartPhone：智能手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="comment">//重写父类的来电显示功能的方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//来电显示姓名和图片功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显示来电姓名&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;显示头像&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写父类的通话功能的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;语音通话 或 视频通话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOverride</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        <span class="type">SmartPhone</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartPhone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用父类继承而来的方法</span></span><br><span class="line">        sp.call();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用子类重写的方法</span></span><br><span class="line">        sp.showNum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Override使用说明：</p>
<p>写在方法上面，用来检测是不是满足重写方法的要求。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。建议保留，这样编译器可以帮助我们检查格式，另外也可以让阅读源代码的程序员清晰的知道这是一个重写的方法。</p>
<p>方法重写的要求</p>
<ol>
<li><p>子类重写的方法<code>必须</code>和父类被重写的方法具有相同的<code>方法名称</code>、<code>参数列表</code>。</p>
</li>
<li><p>子类重写的方法的返回值类型<code>不能大于</code>父类被重写的方法的返回值类型。（例如：Student &lt; Person）。</p>
</li>
</ol>
<blockquote>
<p>注意：如果返回值类型是基本数据类型和void，那么必须是相同</p>
</blockquote>
<ol start="3">
<li>子类重写的方法使用的访问权限<code>不能小于</code>父类被重写的方法的访问权限。（public &gt; protected &gt; 缺省 &gt; private）</li>
</ol>
<blockquote>
<p>注意：① 父类私有方法不能重写   ② 跨包的父类缺省的方法也不能重写</p>
</blockquote>
<ol start="4">
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ol>
<p>此外，子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</p>
<p>小结：方法的重载与重写</p>
<p>方法的重载：方法名相同，形参列表不同。不看返回值类型。</p>
<p>方法的重写：见上面。</p>
<h3 id="4-再谈封装性中的4种权限修饰"><a href="#4-再谈封装性中的4种权限修饰" class="headerlink" title="4.再谈封装性中的4种权限修饰"></a>4.再谈封装性中的4种权限修饰</h3><p>权限修饰符：public,protected,缺省,private</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>本类</th>
<th>本包</th>
<th>其他包子类</th>
<th>其他包非子类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>缺省</td>
<td>√</td>
<td>√（本包子类非子类都可见）</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√（本包子类非子类都可见）</td>
<td>√（其他包仅限于子类中可见）</td>
<td>×</td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>外部类：public和缺省</p>
<p>成员变量、成员方法等：public,protected,缺省,private</p>
<p><strong>1、外部类要跨包使用必须是public，否则仅限于本包使用</strong></p>
<p>（1）外部类的权限修饰符如果缺省，本包使用没问题</p>
<p><img src="D:\Java入门教程\01_课件与电子教材\01_课件与电子教材\尚硅谷_第07章_面向对象编程（进阶）\images\image-20211230093627763.png" alt="image-20211230093627763"></p>
<p>（2）外部类的权限修饰符如果缺省，跨包使用有问题</p>
<p><img src="D:\Java入门教程\01_课件与电子教材\01_课件与电子教材\尚硅谷_第07章_面向对象编程（进阶）\images\image-20211230094236974.png" alt="image-20211230094236974"></p>
<p><strong>2、成员的权限修饰符问题</strong></p>
<p>（1）本包下使用：成员的权限修饰符可以是public、protected、缺省</p>
<p><img src="D:\Java入门教程\01_课件与电子教材\01_课件与电子教材\尚硅谷_第07章_面向对象编程（进阶）\images\image-20211230095320646.png" alt="image-20211230095320646"></p>
<p>（2）跨包下使用：要求严格</p>
<img src="D:\Java入门教程\01_课件与电子教材\01_课件与电子教材\尚硅谷_第07章_面向对象编程（进阶）\images\image-20211230095817784.png" alt="image-20211230095817784" style="zoom: 80%;" />

<p>（3）跨包使用时，如果类的权限修饰符缺省，成员权限修饰符&gt;类的权限修饰符也没有意义</p>
<p><img src="D:\Java入门教程\01_课件与电子教材\01_课件与电子教材\尚硅谷_第07章_面向对象编程（进阶）\images\image-20211230100219840.png" alt="image-20211230100219840"></p>
<p>总结：</p>
<p>一、测试4种权限修饰<br>在com.atguigu04.override包下创建两个package：test1和test2，测试Java中提供的4种权限修饰</p>
<p>实际开发中，各权限修饰的使用频率是怎样的？ public、private是使用频率最高的！</p>
<p>二、方法的重写(overwrite &#x2F; override)</p>
<ol>
<li>为什么需要方法的重写？</li>
</ol>
<p>子类在继承父类以后，就获取了父类中声明的所有的方法。但是，父类中的方法可能不太适用于子类，换句话说，子类<br>需要对父类中继承过来的方法进行覆盖、覆写的操作。</p>
<p>举例（银行账户）：</p>
<p>class Account{&#x2F;&#x2F;账户<br>    double balance;&#x2F;&#x2F;余额</p>
<pre><code>//取钱
public void withdraw(double amt)&#123;
    //判断balance余额是否够amt取钱的额度
&#125;
</code></pre>
<p>}</p>
<p>class CheckAccount extends Account{ &#x2F;&#x2F;信用卡<br>    double protectedBy;&#x2F;&#x2F;透支额度</p>
<pre><code>public void withdraw(double amt)&#123;
    //判断balance余额是否够amt取钱的额度
    //如果不够，还可以考虑从protectedBy额度里取
&#125;
</code></pre>
<p>}</p>
<p>class AccountTest{<br>    public static void main(String[] args){<br>        CheckAccount acct &#x3D; new CheckAccount();<br>        acct.withdraw(); &#x2F;&#x2F;执行的是子类重写父类的方法<br>    }<br>}</p>
<ol start="2">
<li>何为方法的重写？</li>
</ol>
<p>子类对父类继承过来的方法进行的覆盖、覆写的操作，就称为方法的重写。</p>
<ol start="3">
<li>方法重写应遵循的规则</li>
</ol>
<p>[复习]方法声明的格式：权限修饰符 返回值类型 方法名(形参列表) [throws 异常类型] { &#x2F;&#x2F;方法体 }</p>
<p>具体规则：<br>① 父类被重写的方法与子类重写的方法的方法名和形参列表必须相同。<br>② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</p>
<blockquote>
<p>子类不能重写父类中声明为private权限修饰的方法。<br>③ 关于返回值类型：<br>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型必须是void<br>父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须与被重写的方法的返回值类型相同。<br>父类被重写的方法的返回值类型是引用数据类型(比如类)，则子类重写的方法的返回值类型可以与被重写的方法的返回值<br>类型相同 或 是被重写的方法的返回值类型的子类<br>④ （超纲）子类重写的方法抛出的异常类型可以与父类被重写的方法抛出的异常类型相同，或是父类被重写的方法抛出的异常类型的子类。</p>
</blockquote>
<p>补充说明：方法体：没有要求。但是子类重写的方法的方法体必然与父类被重写的方法的不同。</p>
<ol start="4">
<li>面试题：区分方法的重载(overload)与重写(override &#x2F; overwrite)</li>
</ol>
<p>重载：“两同一不同”<br>重写：继承以后，子类覆盖父类中同名同参数的方法</p>
<p>[类比]相同类型的面试题：</p>
<p>throws &#x2F; throw<br>final &#x2F; finally &#x2F; finalize<br>Collection &#x2F; Collections<br>String &#x2F; StringBuffer &#x2F; StringBuilder<br>ArrayList &#x2F; LinkedList<br>HashMap &#x2F; LinkedHashMap &#x2F; Hashtable<br>…</p>
<p>sleep() &#x2F; wait()<br>&#x3D;&#x3D; &#x2F; equals()<br>同步 &#x2F; 异步</p>
<h3 id="5-关键字：super"><a href="#5-关键字：super" class="headerlink" title="5.关键字：super"></a>5.关键字：super</h3><p>5.1 super的理解</p>
<p>在Java类中使用super来调用父类中的指定操作：</p>
<ul>
<li>super可用于访问父类中定义的属性</li>
<li>super可用于调用父类中定义的成员方法</li>
<li>super可用于在子类构造器中调用父类的构造器</li>
</ul>
<p>注意：</p>
<ul>
<li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</li>
<li>super的追溯不仅限于直接父类</li>
<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li>
</ul>
<p>super的使用场景</p>
<p>5.2.1 子类中调用父类被重写的方法</p>
<ul>
<li>如果子类没有重写父类的方法，只要权限修饰符允许，在子类中完全可以直接调用父类的方法；</li>
<li>如果子类重写了父类的方法，在子类中需要通过<code>super.</code>才能调用父类被重写的方法，否则默认调用的子类重写的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来电显示号码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//smartphone：智能手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="comment">//重写父类的来电显示功能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//来电显示姓名和图片功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显示来电姓名&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;显示头像&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保留父类来电显示号码的功能</span></span><br><span class="line">        <span class="built_in">super</span>.showNum();<span class="comment">//此处必须加super.，否则就是无限递归，那么就会栈内存溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p><strong>方法前面没有super.和this.</strong></p>
<ul>
<li>先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯</li>
</ul>
</li>
<li><p><strong>方法前面有this.</strong></p>
<ul>
<li>先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯</li>
</ul>
</li>
<li><p><strong>方法前面有super.</strong></p>
<ul>
<li>从当前子类的直接父类找，如果没有，继续往上追溯</li>
</ul>
</li>
</ul>
<p>子类中调用父类中同名的成员变量</p>
<ul>
<li>如果实例变量与局部变量重名，可以在实例变量前面加this.进行区别</li>
<li>如果子类实例变量和父类实例变量重名，并且父类的该实例变量在子类仍然可见，在子类中要访问父类声明的实例变量需要在父类实例变量前加super.，否则默认访问的是子类自己声明的实例变量</li>
<li>如果父子类实例变量没有重名，只要权限修饰符允许，在子类中完全可以直接访问父类中声明的实例变量，也可以用this.实例访问，也可以用super.实例变量访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//子类与父类的属性同名，子类对象中就有两个a</span></span><br><span class="line">		System.out.println(<span class="string">&quot;子类的a：&quot;</span> + a);<span class="comment">//20  先找局部变量找，没有再从本类成员变量找</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类的a：&quot;</span> + <span class="built_in">this</span>.a);<span class="comment">//20   先从本类成员变量找</span></span><br><span class="line">        System.out.println(<span class="string">&quot;父类的a：&quot;</span> + <span class="built_in">super</span>.a);<span class="comment">//10    直接从父类成员变量找</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//子类与父类的属性不同名，是同一个b</span></span><br><span class="line">		System.out.println(<span class="string">&quot;b = &quot;</span> + b);<span class="comment">//11  先找局部变量找，没有再从本类成员变量找，没有再从父类找</span></span><br><span class="line">		System.out.println(<span class="string">&quot;b = &quot;</span> + <span class="built_in">this</span>.b);<span class="comment">//11   先从本类成员变量找，没有再从父类找</span></span><br><span class="line">		System.out.println(<span class="string">&quot;b = &quot;</span> + <span class="built_in">super</span>.b);<span class="comment">//11  直接从父类局部变量找</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">		<span class="comment">//子类与父类的属性同名，子类对象中就有两个成员变量a，此时方法中还有一个局部变量a		</span></span><br><span class="line">		System.out.println(<span class="string">&quot;局部变量的a：&quot;</span> + a);<span class="comment">//30  先找局部变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类的a：&quot;</span> + <span class="built_in">this</span>.a);<span class="comment">//20  先从本类成员变量找</span></span><br><span class="line">        System.out.println(<span class="string">&quot;父类的a：&quot;</span> + <span class="built_in">super</span>.a);<span class="comment">//10  直接从父类成员变量找</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);<span class="comment">//13  先找局部变量</span></span><br><span class="line">		System.out.println(<span class="string">&quot;b = &quot;</span> + <span class="built_in">this</span>.b);<span class="comment">//11  先从本类成员变量找</span></span><br><span class="line">		System.out.println(<span class="string">&quot;b = &quot;</span> + <span class="built_in">super</span>.b);<span class="comment">//11  直接从父类局部变量找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">		son.test();</span><br><span class="line">		son.method(<span class="number">30</span>,<span class="number">13</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：起点不同（就近原则）</p>
<ul>
<li><p><strong>变量前面没有super.和this.</strong></p>
<ul>
<li>在构造器、代码块、方法中如果出现使用某个变量，先查看是否是当前块声明的<code>局部变量</code>，</li>
<li>如果不是局部变量，先从当前执行代码的<code>本类去找成员变量</code></li>
<li>如果从当前执行代码的本类中没有找到，会往上找<code>父类声明的成员变量</code>（权限修饰符允许在子类中访问的）</li>
</ul>
</li>
<li><p><strong>变量前面有this.</strong> </p>
<ul>
<li>通过this找成员变量时，先从当前执行代码的&#x3D;&#x3D;本类去找成员变量&#x3D;&#x3D;</li>
<li>如果从当前执行代码的本类中没有找到，会往上找&#x3D;&#x3D;父类声明的成员变量（&#x3D;&#x3D;权限修饰符允许在子类中访问的）</li>
</ul>
</li>
<li><p><strong>变量前面super.</strong> </p>
<ul>
<li>通过super找成员变量，直接从当前执行代码的直接父类去找成员变量（权限修饰符允许在子类中访问的）</li>
<li>如果直接父类没有，就去父类的父类中找（权限修饰符允许在子类中访问的）</li>
</ul>
</li>
</ul>
<p>5.2.3 子类构造器中调用父类构造器</p>
<p>① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。</p>
<p>② 规定：“super(形参列表)”，必须声明在构造器的首行。</p>
<p>③ 我们前面讲过，在构造器的首行可以使用”this(形参列表)”，调用本类中重载的构造器，<br>     结合②，结论：在构造器的首行，”this(形参列表)” 和 “super(形参列表)”只能二选一。</p>
<p>④ 如果在子类构造器的首行既没有显示调用”this(形参列表)”，也没有显式调用”super(形参列表)”，<br>​     则子类此构造器默认调用”super()”，即调用父类中空参的构造器。</p>
<p>⑤ 由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。<br>     只能是这两种情况之一。</p>
<p>⑥ 由⑤得到：一个类中声明有n个构造器，最多有n-1个构造器中使用了”this(形参列表)”，则剩下的那个一定使用”super(形参列表)”。</p>
<blockquote>
<p>开发中常见错误：</p>
<p>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则<code>编译出错</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//A类和B类都是默认有一个无参构造，B类的默认无参构造中还会默认调用A类的默认无参构造</span></span><br><span class="line">        <span class="comment">//但是因为都是默认的，没有打印语句，看不出来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.3 小结：this与super</p>
<p><strong>1、this和super的意义</strong></p>
<p>this：当前对象</p>
<ul>
<li>在构造器和非静态代码块中，表示正在new的对象</li>
<li>在实例方法中，表示调用当前方法的对象</li>
</ul>
<p>super：引用父类声明的成员</p>
<p><strong>2、this和super的使用格式</strong></p>
<ul>
<li>this<ul>
<li>this.成员变量：表示当前对象的某个成员变量，而不是局部变量</li>
<li>this.成员方法：表示当前对象的某个成员方法，完全可以省略this.</li>
<li>this()或this(实参列表)：调用另一个构造器协助当前对象的实例化，只能在构造器首行，只会找本类的构造器，找不到就报错</li>
</ul>
</li>
<li>super<ul>
<li>super.成员变量：表示当前对象的某个成员变量，该成员变量在父类中声明的</li>
<li>super.成员方法：表示当前对象的某个成员方法，该成员方法在父类中声明的</li>
<li>super()或super(实参列表)：调用父类的构造器协助当前对象的实例化，只能在构造器首行，只会找直接父类的对应构造器，找不到就报错</li>
</ul>
</li>
</ul>
<p>总结：</p>
<p>一、super关键字的使用</p>
<ol>
<li>为什么需要super？</li>
</ol>
<p>举例1：子类继承父类以后，对父类的方法进行了重写，那么在子类中，是否还可以对父类中被重写的方法进行调用？<br>可以！</p>
<p>举例2：子类继承父类以后，发现子类和父类中定义了同名的属性，是否可以在子类中区分两个同名的属性？<br>可以！</p>
<p>如何调用？ 使用super关键字即可。</p>
<ol start="2">
<li><p>super的理解：父类的</p>
</li>
<li><p>super可以调用的结构：属性、方法、构造器</p>
</li>
</ol>
<p>具体的：<br>3.1 super调用属性、方法</p>
<p>子类继承父类以后，我们就可以在子类的方法或构造器中，调用父类中声明的属性或方法。（满足封装性的前提下）<br>如何调用呢？需要使用”super.”的结构，表示调用父类的属性或方法。<br>一般情况下，我们可以考虑省略”super.”的结构。但是，如果出现子类重写了父类的方法或子父类中出现了同名的属性时，<br>则必须使用”super.”的声明，显式的调用父类被重写的方法或父类中声明的同名的属性。</p>
<p>3.2 super调用构造器<br>① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。<br>② 规定：“super(形参列表)”，必须声明在构造器的首行。<br>③ 我们前面讲过，在构造器的首行可以使用”this(形参列表)”，调用本类中重载的构造器，<br>   结合②，结论：在构造器的首行，”this(形参列表)” 和 “super(形参列表)”只能二选一。<br>④ 如果在子类构造器的首行既没有显示调用”this(形参列表)”，也没有显式调用”super(形参列表)”，<br>  则子类此构造器默认调用”super()”，即调用父类中空参的构造器。<br>⑤ 由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。<br>     只能是这两种情况之一。<br>⑥ 由⑤得到：一个类中声明有n个构造器，最多有n-1个构造器中使用了”this(形参列表)”，<br>   则剩下的那个一定使用”super(形参列表)”。</p>
<p>–&gt; 我们在通过子类的构造器创建对象时，一定在调用子类构造器的过程中，直接或间接的调用到父类的构造器。<br>也正因为调用过父类的构造器，我们才会将父类中声明的属性或方法加载到内存中，供子类对象使用。</p>
<p>二、子类对象实例化全过程</p>
<p>代码举例：</p>
<p>class Creature{ &#x2F;&#x2F;生物类<br>    &#x2F;&#x2F;声明属性、方法、构造器<br>}</p>
<p>class Animal extends Creature{ &#x2F;&#x2F;动物类</p>
<p>}</p>
<p>class Dog extends Animal{ &#x2F;&#x2F;狗类</p>
<p>}</p>
<p>class DogTest{<br>    public static void main(String[] args){<br>        Dog dog &#x3D; new Dog();<br>        dog.xxx();<br>        dog.yyy &#x3D; …;<br>    }<br>}</p>
<ol>
<li>从结果的角度来看：体现为类的继承性</li>
</ol>
<p>当我们创建子类对象后，子类对象就获取了其父类中声明的所有的属性和方法，在权限允许的情况下，可以直接调用。</p>
<ol start="2">
<li>从过程的角度来看：</li>
</ol>
<p>当我们通过子类的构造器创建对象时，子类的构造器一定会直接或间接的调用到其父类的构造器，而其父类的构造器<br>同样会直接或间接的调用到其父类的父类的构造器，….，直到调用了Object类中的构造器为止。</p>
<p>正因为我们调用过子类所有的父类的构造器，所以我们就会将父类中声明的属性、方法加载到内存中，供子类的对象使用。</p>
<p>问题：在创建子类对象的过程中，一定会调用父类中的构造器吗？ yes!</p>
<ol start="3">
<li>问题：创建子类的对象时，内存中到底有几个对象？<br>就只有一个对象！即为当前new后面构造器对应的类的对象。</li>
</ol>
<h3 id="6-子类对象实例化全过程"><a href="#6-子类对象实例化全过程" class="headerlink" title="6. 子类对象实例化全过程"></a>6. 子类对象实例化全过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小花&quot;</span>,<span class="string">&quot;小红&quot;</span>);</span><br></pre></td></tr></table></figure>

<img src="D:\Java入门教程\01_课件与电子教材\01_课件与电子教材\尚硅谷_第07章_面向对象编程（进阶）\images\image-20220324003735416.png" alt="image-20220324003735416" style="zoom:80%;" />

<img src="D:\Java入门教程\01_课件与电子教材\01_课件与电子教材\尚硅谷_第07章_面向对象编程（进阶）\images\image-20220324003813163.png" alt="image-20220324003813163" style="zoom:67%;" />

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Creature</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creature无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal带一个参数的构造器，该动物的name为&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal带两个参数的构造器，其age为&quot;</span> + age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;汪汪队阿奇&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog无参数的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-面向对象特征三：多态性"><a href="#7-面向对象特征三：多态性" class="headerlink" title="7.面向对象特征三：多态性"></a>7.面向对象特征三：多态性</h3><p>多态的形式和体现</p>
<p>7.1.1 对象的多态性</p>
<p>多态性，是面向对象中最重要的概念，在Java中的体现：<strong>对象的多态性：父类的引用指向子类的对象</strong></p>
<p>格式：（父类类型：指子类继承的父类类型，或者实现的接口类型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 变量名 = 子类对象；</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();<span class="comment">//Object类型的变量o，指向Person类型的对象</span></span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">//Object类型的变量o，指向Student类型的对象</span></span><br></pre></td></tr></table></figure>

<p>对象的多态：在Java中，子类的对象可以替代父类的对象使用。所以，一个引用类型变量可能指向(引用)多种不同类型的对象</p>
<p>多态的理解</p>
<p>Java引用变量有两个类型：<code>编译时类型</code>和<code>运行时类型</code>。编译时类型由<code>声明</code>该变量时使用的类型决定，运行时类型由<code>实际赋给该变量的对象</code>决定。简称：<strong>编译时，看左边；运行时，看右边。</strong></p>
<ul>
<li>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)</li>
<li>多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法）<br>“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）</li>
</ul>
<p>多态的使用前提：① 类的继承关系  ② 方法的重写</p>
<p>7.1.3 举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String nickname; <span class="comment">//昵称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNickname</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNickname</span><span class="params">(String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(nickname + <span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="comment">//子类重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫咪&quot;</span> + getNickname() + <span class="string">&quot;吃鱼仔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类扩展的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="comment">//子类重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗子&quot;</span> + getNickname() + <span class="string">&quot;啃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类扩展的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;看家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、方法内局部变量的赋值体现多态</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多态引用</span></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        pet.setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//多态的表现形式</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        编译时看父类：只能调用父类声明的方法，不能调用子类扩展的方法；</span></span><br><span class="line"><span class="comment">        运行时，看“子类”，如果子类重写了方法，一定是执行子类重写的方法体；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pet.eat();<span class="comment">//运行时执行子类Dog重写的方法</span></span><br><span class="line"><span class="comment">//      pet.watchHouse();//不能调用Dog子类扩展的方法</span></span><br><span class="line"></span><br><span class="line">        pet = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        pet.setNickname(<span class="string">&quot;雪球&quot;</span>);</span><br><span class="line">        pet.eat();<span class="comment">//运行时执行子类Cat重写的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、方法的形参声明体现多态</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adopt</span><span class="params">(Pet pet)</span> &#123;<span class="comment">//形参是父类类型，实参是子类对象</span></span><br><span class="line">        <span class="built_in">this</span>.pet = pet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">()</span>&#123;</span><br><span class="line">        pet.eat();<span class="comment">//pet实际引用的对象类型不同，执行的eat方法也不同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPerson</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        person.adopt(dog);<span class="comment">//实参是dog子类对象，形参是父类Pet类型</span></span><br><span class="line">        person.feed();</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.setNickname(<span class="string">&quot;雪球&quot;</span>);</span><br><span class="line">        person.adopt(cat);<span class="comment">//实参是cat子类对象，形参是父类Pet类型</span></span><br><span class="line">        person.feed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、方法返回值类型体现多态</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PetShop</span> &#123;</span><br><span class="line">    <span class="comment">//返回值类型是父类类型，实际返回的是子类对象</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">sale</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Dog&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Cat&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPetShop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PetShop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PetShop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">dog</span> <span class="operator">=</span> shop.sale(<span class="string">&quot;Dog&quot;</span>);</span><br><span class="line">        dog.setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        dog.eat();</span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">cat</span> <span class="operator">=</span> shop.sale(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">        cat.setNickname(<span class="string">&quot;雪球&quot;</span>);</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多态的好处和弊端</p>
<p><strong>好处</strong>：变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。</p>
<p><strong>弊端</strong>：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">m.school = <span class="string">&quot;pku&quot;</span>; 	<span class="comment">//合法,Student类有school成员变量</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); </span><br><span class="line">e.school = <span class="string">&quot;pku&quot;</span>;	<span class="comment">//非法,Person类没有school成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。</span></span><br></pre></td></tr></table></figure>

<p>开发中：</p>
<p>使用父类做方法的形参，是多态使用最多的场合。即使增加了新的子类，方法也无需改变，提高了扩展性，符合开闭原则。</p>
<p>【开闭原则OCP】</p>
<ul>
<li>对扩展开放，对修改关闭</li>
<li>通俗解释：软件系统中的各种组件，如模块（Modules）、类（Classes）以及功能（Functions）等，应该在不修改现有代码的基础上，引入新功能</li>
</ul>
<p>虚方法调用(Virtual Method Invocation)</p>
<p>在Java中虚方法是指在编译阶段不能确定方法的调用入口地址，在运行阶段才能确定的方法，即可能被重写的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">e.getInfo();	<span class="comment">//调用Student类的getInfo()方法</span></span><br></pre></td></tr></table></figure>

<p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</p>
<p>成员变量没有多态性</p>
<ul>
<li><p>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。</p>
</li>
<li><p>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量</p>
</li>
</ul>
<p>向上转型与向下转型</p>
<ul>
<li><p><strong>向上转型</strong>：当左边的变量的类型（父类） &gt; 右边对象&#x2F;变量的类型（子类），我们就称为向上转型</p>
<ul>
<li>此时，编译时按照左边变量的类型处理，就只能调用父类中有的变量和方法，不能调用子类特有的变量和方法了</li>
<li>但是，<strong>运行时，仍然是对象本身的类型</strong>，所以执行的方法是子类重写的方法体。</li>
<li>此时，一定是安全的，而且也是自动完成的</li>
</ul>
</li>
<li><p><strong>向下转型</strong>：当左边的变量的类型（子类）&lt;右边对象&#x2F;变量的编译时类型（父类），我们就称为向下转型</p>
<ul>
<li>此时，编译时按照左边变量的类型处理，就可以调用子类特有的变量和方法了</li>
<li>但是，<strong>运行时，仍然是对象本身的类型</strong></li>
<li>不是所有通过编译的向下转型都是正确的，可能会发生ClassCastException，为了安全，可以通过isInstanceof关键字进行判断</li>
</ul>
</li>
</ul>
<p> 如何向上或向下转型</p>
<p>向上转型：自动完成</p>
<p>向下转型：（子类类型）父类变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassCastTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//没有类型转换</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//dog的编译时类型和运行时类型都是Dog</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上转型</span></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//pet的编译时类型是Pet，运行时类型是Dog</span></span><br><span class="line">        pet.setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        pet.eat();<span class="comment">//可以调用父类Pet有声明的方法eat，但执行的是子类重写的eat方法体</span></span><br><span class="line"><span class="comment">//        pet.watchHouse();//不能调用父类没有的方法watchHouse</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog) pet;</span><br><span class="line">        System.out.println(<span class="string">&quot;d.nickname = &quot;</span> + d.getNickname());</span><br><span class="line">        d.eat();<span class="comment">//可以调用eat方法</span></span><br><span class="line">        d.watchHouse();<span class="comment">//可以调用子类扩展的方法watchHouse</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat) pet;<span class="comment">//编译通过，因为从语法检查来说，pet的编译时类型是Pet，Cat是Pet的子类，所以向下转型语法正确</span></span><br><span class="line">        <span class="comment">//这句代码运行报错ClassCastException，因为pet变量的运行时类型是Dog，Dog和Cat之间是没有继承关系的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>instanceof关键字</p>
<p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验。如下代码格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检验对象a是否是数据类型A的对象，返回值为boolean型</span></span><br><span class="line">对象a <span class="keyword">instanceof</span> 数据类型A </span><br></pre></td></tr></table></figure>

<ul>
<li>说明：<ul>
<li>只要用instanceof判断返回true的，那么强转为该类型就一定是安全的，不会报ClassCastException异常。</li>
<li>如果对象a属于类A的子类B，a instanceof A值也为true。</li>
<li>要求对象a所属的类与类A必须是子类和父类的关系，否则编译错误。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInstanceof</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pet[] pets = <span class="keyword">new</span> <span class="title class_">Pet</span>[<span class="number">2</span>];</span><br><span class="line">        pets[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//多态引用</span></span><br><span class="line">        pets[<span class="number">0</span>].setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        pets[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//多态引用</span></span><br><span class="line">        pets[<span class="number">1</span>].setNickname(<span class="string">&quot;雪球&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pets.length; i++) &#123;</span><br><span class="line">            pets[i].eat();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pets[i] <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">                <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) pets[i];</span><br><span class="line">                dog.watchHouse();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pets[i] <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">                <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) pets[i];</span><br><span class="line">                cat.catchMouse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>面向对象特征之三：多态性</p>
<ol>
<li>如何理解多态性？</li>
</ol>
<p>理解：理解为一个事物的多种形态。</p>
<p>生活举例：</p>
<blockquote>
<p>女朋友：我想养一个宠物。<br>孩子：我想要一个玩具。<br>老板：张秘书，安排一个技术科的同事，跟我一起下周出差。</p>
</blockquote>
<ol start="2">
<li><p>Java中多态性的体现:<br>子类对象的多态性：父类的引用指向子类的对象。（或子类的对象赋给父类的引用）<br>比如:Person p2 &#x3D; new Man();</p>
</li>
<li><p>多态性的应用：<br>多态性的应用：虚拟方法调用</p>
</li>
</ol>
<p>在多态的场景下，调用方法时。<br>    编译时，认为方法是左边声明的父类的类型的方法（即被重写的方法）<br>    执行式，实际执行的是子类重写父类的方法。<br>简称为：编译看左边，运行看右边。</p>
<ol start="4">
<li><p>多态性的使用前提：① 要有类的继承关系 ② 要有方法的重写</p>
</li>
<li><p>多态的适用性：适用于方法，不适用于属性。</p>
</li>
<li><p>多态的好处与弊端<br>6.1 弊端：<br>在多态的场景下，我们创建了子类的对象，也加载了子类特有的属性和方法。但是由于声明为父类的引用，<br>导致我们没有办法直接调用子类特有的属性和方法。</p>
</li>
</ol>
<p>6.2 好处：<br>极大的减少了代码的冗余，不需要定义多个重载的方法。</p>
<p>举例：</p>
<p>class Account{<br>    public void withdraw(){} &#x2F;&#x2F;取钱<br>}</p>
<p>class CheckAccount extends Account{ &#x2F;&#x2F;信用卡<br>    &#x2F;&#x2F;存在方法的重写<br>    public void withdraw(){} &#x2F;&#x2F;取钱<br>}<br>class SavingAccount extends Account{ &#x2F;&#x2F;储蓄卡<br>    &#x2F;&#x2F;存在方法的重写<br>}</p>
<p>class Customer{<br>    Account account;</p>
<pre><code>public void setAccount(Account account)&#123;
    this.account = account;
&#125;

public Account getAccount()&#123;
    return accout;
&#125;
</code></pre>
<p>}</p>
<p>class CustomerTest{<br>    main(){<br>        Customer cust &#x3D; new Customer();<br>        cust.setAccount(new CheckAccount());</p>
<pre><code>    cust.getAccount().withdraw();

&#125;
</code></pre>
<p>}</p>
<ol start="7">
<li>instanceof的使用</li>
</ol>
<p>&#x2F;*</p>
<ul>
<li><ol>
<li>建议在向下转型之前，使用instanceof进行判断，避免出现类型转换异常</li>
</ol>
</li>
<li><ol start="2">
<li>格式： a instanceOf A : 判断对象a是否是类A的实例。</li>
</ol>
</li>
<li><ol start="3">
<li>如果a instanceOf A 返回true，则：</li>
</ol>
</li>
<li>a instanceOf superA 返回也是true。其中，A 是superA的子类。</li>
<li>*&#x2F;</li>
</ul>
<h3 id="8-Object-类的使用"><a href="#8-Object-类的使用" class="headerlink" title="8.Object 类的使用"></a>8.Object 类的使用</h3><p>类 <code>java.lang.Object</code>是类层次结构的根类，即所有其它类的父类。每个类都使用 <code>Object</code> 作为超类。</p>
<ul>
<li><p>Object类型的变量与除Object以外的任意引用数据类型的对象都存在多态引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method(Object obj)&#123;…&#125; <span class="comment">//可以接收任何类作为其参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  </span><br><span class="line">method(o);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>所有对象（包括数组）都实现这个类的方法。</p>
</li>
<li><p>如果一个类没有特别指定父类，那么默认则继承自Object类。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object类的方法</p>
<p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。这里我们主要关注其中的6个：</p>
<p>1、(重点)equals()</p>
<p><strong>&#x3D; &#x3D;：</strong> </p>
<ul>
<li><p>基本类型比较值:只要两个变量的值相等，即为true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>; </span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">6</span>)&#123;…&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，&#x3D;&#x3D;才返回true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>();  	    </span><br><span class="line">Person p2=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">if</span> (p1==p2)&#123;…&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用“&#x3D;&#x3D;”进行比较时，符号两边的<code>数据类型必须兼容</code>(可自动转换的基本数据类型除外)，否则编译出错</li>
</ul>
</li>
</ul>
<p><strong>equals()：</strong>所有类都继承了Object，也就获得了equals()方法。还可以重写。</p>
<img src="C:\Users\ieerc\AppData\Roaming\Typora\typora-user-images\image-20230602104539575.png" alt="image-20230602104539575" style="zoom: 50%;" />

<ul>
<li><p>只能比较引用类型，Object类源码中equals()的作用与“&#x3D;&#x3D;”相同：比较是否指向同一个对象。	 </p>
</li>
<li><p>格式:obj1.equals(obj2)</p>
</li>
<li><p>特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象；</p>
<ul>
<li>原因：在这些类中重写了Object类的equals()方法。</li>
</ul>
</li>
<li><p>当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等</p>
</li>
<li><p>重写equals()方法的原则</p>
<ul>
<li><p><code>对称性</code>：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。</p>
</li>
<li><p><code>自反性</code>：x.equals(x)必须返回是“true”。</p>
</li>
<li><p><code>传递性</code>：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。</p>
</li>
<li><p><code>一致性</code>：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。</p>
</li>
<li><p>任何情况下，x.equals(null)，永远返回是“false”；</p>
<p>​    x.equals(和x不同类型的对象)永远返回是“false”。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String host;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String host, String username, String password)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.host = host;</span><br><span class="line">		<span class="built_in">this</span>.username = username;</span><br><span class="line">		<span class="built_in">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> host;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHost</span><span class="params">(String host)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.host = host;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> username;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.username = username;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> password;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;User [host=&quot;</span> + host + <span class="string">&quot;, username=&quot;</span> + username + <span class="string">&quot;, password=&quot;</span> + password + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="type">User</span> <span class="variable">other</span> <span class="operator">=</span> (User) obj;</span><br><span class="line">		<span class="keyword">if</span> (host == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (other.host != <span class="literal">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!host.equals(other.host))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (password == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (other.password != <span class="literal">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!password.equals(other.password))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (username == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (other.username != <span class="literal">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!username.equals(other.username))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	&#x3D;&#x3D;和equals的区别</p>
<ul>
<li><p>&#x3D;&#x3D; 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</p>
</li>
<li><p>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是&#x3D;&#x3D;;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。</p>
</li>
<li><p>具体要看自定义类里有没有重写Object的equals方法来判断。</p>
</li>
<li><p>通常情况下，重写equals方法，会比较类中的相应属性是否都相等。</p>
</li>
</ul>
<p>2、(重点)toString()</p>
<p>方法签名：public String toString()</p>
<p>① 默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式”</p>
<p>② 在进行String与其它类型数据的连接操作时，自动调用toString()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date now=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(“now=”+now);  <span class="comment">//相当于</span></span><br><span class="line">System.out.println(“now=”+now.toString()); </span><br></pre></td></tr></table></figure>

<p>③ 如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()</p>
<blockquote>
<p>因为Java的引用数据类型的变量中存储的实际上时对象的内存地址，但是Java对程序员隐藏内存地址信息，所以不能直接将内存地址显示出来，所以当你打印对象时，JVM帮你调用了对象的toString()。</p>
</blockquote>
<p>④ 可以根据需要在用户自定义类型中重写toString()方法<br>    如String 类重写了toString()方法，返回字符串的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1);<span class="comment">//相当于System.out.println(s1.toString());</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>Object类的概述</p>
<ol>
<li>Object类的说明</li>
</ol>
<blockquote>
<p>明确：java.lang.Object<br>任何一个Java类（除Object类）都直接或间接的继承于Object类<br>Object类称为java类的根父类<br>Object类中声明的结构（属性、方法等）就具有通用性。<br>Object类中没有声明属性<br>Object类提供了一个空参的构造器<br>重点关注：Object类中声明的方法</p>
</blockquote>
<ol start="2">
<li>常用方法<br>重点方法：equals() \ toString()<br>了解方法：clone() \ finalize()<br>目前不需要关注：getClass() \ hashCode() \ notify() \ notifyAll() \ wait() \ wait(xx) \ wait(xx,yy)</li>
</ol>
<p>面试题：final 、 finally 、 finalize 的区别</p>
<ol start="3">
<li>equals()的使用</li>
</ol>
<p>3.1 适用性：<br>任何引用数据类型都可以使用。</p>
<p>3.2 java.lang.Object类中equals()的定义：<br>public boolean equals(Object obj) {<br>    return (this &#x3D;&#x3D; obj);<br>}</p>
<p>3.3 子类使用说明：</p>
<blockquote>
<p>自定义的类在没有重写Object中equals()方法的情况下，调用的就是Object类中声明的equals()，比较两个<br>对象的引用地址是否相同。（或比较两个对象是否指向了堆空间中的同一个对象实体）</p>
</blockquote>
<blockquote>
<p>对于像String、File、Date和包装类等，它们都重写了Object类中的equals()方法，用于比较两个对象的<br>实体内容是否相等。</p>
</blockquote>
<p>3.4 开发中使用说明：</p>
<blockquote>
<p>实际开发中，针对于自定义的类，常常会判断两个对象是否equals()，而此时主要是判断两个对象的属性值是否相等。<br>所以：我们要重写Object类的equals()方法。<br>如何重写:<br>手动自己实现<br>调用IDEA自动实现（推荐）</p>
</blockquote>
<p>3.5 高频面试题： 区分 &#x3D;&#x3D; 和 equals()</p>
<p>&#x3D;&#x3D;：运算符<br>①使用范围：基本数据类型、引用数据类型<br>② 基本数据类型：判断数据值是否相等</p>
<p>int i1 &#x3D; 10;<br>int i2 &#x3D; 10;<br>sout(i1 &#x3D;&#x3D; i2);&#x2F;&#x2F;true</p>
<p>char c1 &#x3D; ‘A’;<br>int i3 &#x3D; 65;<br>sout(c1 &#x3D;&#x3D; i3);&#x2F;&#x2F;true</p>
<p>float f1 &#x3D; 12.0F;<br>int i4 &#x3D; 12;<br>sout(f1 &#x3D;&#x3D; i4);&#x2F;&#x2F;true</p>
<p>引用数据类型变量：比较两个引用变量的地址值是否相等。（或比较两个引用是否指向同一个对象实体）</p>
<p>equals()：方法</p>
<blockquote>
<p>使用范围：只能使用在引用数据类型上。<br>具体使用：对于类来说，重写equals()和不重写equals()的区别。</p>
</blockquote>
<ol start="4">
<li>toString()的使用</li>
</ol>
<p>4.1 Object类中toString()的定义：<br>public String toString() {<br>    return getClass().getName() + “@” + Integer.toHexString(hashCode());<br>}</p>
<p>4.2 开发中的使用场景</p>
<blockquote>
<p>平时我们在调用System.out.println()打印对象引用变量时，其实就调用了对象的toString()</p>
</blockquote>
<p>4.3 子类使用说明：</p>
<blockquote>
<p>自定义的类，在没有重写Object类的toString()的情况下，默认返回的是当前对象的地址值。<br>像String、File、Date或包装类等Object的子类，它们都重写了Object类的toString()，在调用toString()时，<br>返回当前对象的实体内容。</p>
</blockquote>
<p>4.4 开发中使用说明：</p>
<blockquote>
<p>习惯上，开发中对于自定义的类在调用toString()时，也希望显示其对象的实体内容，而非地址值。这时候，就需要重写Object<br>类中的toString().</p>
</blockquote>
<h2 id="面向对象编程-高级"><a href="#面向对象编程-高级" class="headerlink" title="面向对象编程(高级)"></a>面向对象编程(高级)</h2><h3 id="1-关键字：static"><a href="#1-关键字：static" class="headerlink" title="1.关键字：static"></a>1.关键字：static</h3><p><strong>回顾类中的实例变量（即非static的成员变量）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.radius=radius;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI*radius*radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建两个Circle对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Circle c1=<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2.0</span>);	<span class="comment">//c1.radius=2.0</span></span><br><span class="line">Circle c2=<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">3.0</span>);	<span class="comment">//c2.radius=3.0</span></span><br></pre></td></tr></table></figure>

<p>Circle类中的变量radius是一个实例变量(instance variable)，它属于类的每一个对象，c1中的radius变化不会影响c2的radius，反之亦然。</p>
<p><strong>如果想让一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（或类属性）！</strong></p>
<p>1.1 类属性、类方法的设计思想</p>
<p>当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，<code>某些特定的数据在内存空间里只有一份</code>。例如，所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。</p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220325213629311.png" alt="image-20220325213629311"></p>
<p>此外，在类中声明的实例方法，在类的外面必须要先创建对象，才能调用。但是有些方法的调用者和当前类的对象无关，这样的方法通常被声明为<code>类方法</code>，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。</p>
<p>这里的类变量、类方法，只需要使用<code>static</code>修饰即可。所以也称为静态变量、静态方法。</p>
<p>1.2 static关键字</p>
<ul>
<li><p>使用范围：</p>
<ul>
<li>在Java类中，可用static修饰属性、方法、代码块、内部类</li>
</ul>
</li>
<li><p>被修饰后的成员具备以下特点：</p>
<ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰的成员，被所有对象所共享</li>
<li>访问权限允许时，可不创建对象，直接被类调用</li>
</ul>
</li>
</ul>
<p>1.3 静态变量</p>
<p>1.3.1 语法格式</p>
<p>使用static修饰的成员变量就是静态变量（或类变量、类属性）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类&#123;</span><br><span class="line">	[其他修饰符] <span class="keyword">static</span> 数据类型 变量名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.3.2 静态变量的特点</p>
<ul>
<li><p>静态变量的默认值规则和实例变量一样。</p>
</li>
<li><p>静态变量值是所有对象共享。</p>
</li>
<li><p>静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。</p>
</li>
<li><p>如果权限修饰符允许，在其他类中可以通过“<code>类名.静态变量</code>”直接访问，也可以通过“<code>对象.静态变量</code>”的方式访问（但是更推荐使用类名.静态变量的方式）。</p>
</li>
<li><p>静态变量的get&#x2F;set方法也静态的，当局部变量与静态变量<code>重名时</code>，使用“<code>类名.静态变量</code>”进行区分。</p>
</li>
</ul>
<p>1.3.3 举例</p>
<p>举例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//类变量</span></span><br><span class="line">    <span class="keyword">static</span> String nation;<span class="comment">//国籍</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chinese&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, nation=&#x27;&quot;</span> + nation + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;康师傅&quot;</span>,<span class="number">36</span>);</span><br><span class="line">        c1.nation = <span class="string">&quot;中华人民共和国&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;老干妈&quot;</span>,<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line"></span><br><span class="line">        System.out.println(Chinese.nation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的内存结构：（以经典的JDK6内存解析为例，此时静态变量存储在方法区）</p>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220514183814514.png" alt="image-20220514183814514" style="zoom:67%;" />

<p>举例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> total;<span class="comment">//这里私有化，在类的外面必须使用get/set方法的方式来访问静态变量</span></span><br><span class="line">    <span class="keyword">static</span> String company; <span class="comment">//这里缺省权限修饰符，是为了方便类外以“类名.静态变量”的方式访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">        total++;</span><br><span class="line">        id = total;<span class="comment">//这里使用total静态变量的值为id属性赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTotal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setTotal</span><span class="params">(<span class="type">int</span> total)</span> &#123;</span><br><span class="line">        Employee.total = total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee&#123;company = &quot;</span> + company + <span class="string">&quot;,id = &quot;</span> + id + <span class="string">&quot; ,name=&quot;</span> + name +<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStaticVariable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//静态变量total的默认值是0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee.total = &quot;</span> + Employee.getTotal());</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(e1);<span class="comment">//静态变量company的默认值是null</span></span><br><span class="line">        System.out.println(e2);<span class="comment">//静态变量company的默认值是null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee.total = &quot;</span> + Employee.getTotal());<span class="comment">//静态变量total值是2</span></span><br><span class="line"></span><br><span class="line">        Employee.company = <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line">        System.out.println(e1);<span class="comment">//静态变量company的值是尚硅谷</span></span><br><span class="line">        System.out.println(e2);<span class="comment">//静态变量company的值是尚硅谷</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要权限修饰符允许,虽然不推荐，但是也可以通过“对象.静态变量”的形式来访问</span></span><br><span class="line">        e1.company = <span class="string">&quot;超级尚硅谷&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(e1);<span class="comment">//静态变量company的值是超级尚硅谷</span></span><br><span class="line">        System.out.println(e2);<span class="comment">//静态变量company的值是超级尚硅谷</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.3.4 内存解析</p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220104100145059.png" alt="image-20220104100145059"></p>
<p>1.4 静态方法</p>
<p>1.4.1 语法格式</p>
<p>用static修饰的成员方法就是静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类&#123;</span><br><span class="line">	[其他修饰符] <span class="keyword">static</span> 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">        方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.4.2 静态方法的特点</p>
<ul>
<li>静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。</li>
<li>只要权限修饰符允许，静态方法在其他类中可以通过“类名.静态方法“的方式调用。也可以通过”对象.静态方法“的方式调用（但是更推荐使用类名.静态方法的方式）。</li>
<li>在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。</li>
<li>静态方法可以被子类继承，但不能被子类重写。</li>
<li>静态方法的调用都只看编译时类型。</li>
<li>因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。</li>
</ul>
<p>1.4.3 举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.fun&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="comment">//    @Override //尝试重写静态方法，加上@Override编译报错，去掉Override不报错，但是也不是重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son.fun&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStaticMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Father.method();</span><br><span class="line">        Son.method();<span class="comment">//继承静态方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        f.method();<span class="comment">//执行Father类中的method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>static关键字的使用</p>
<ol>
<li><p>static: 静态的</p>
</li>
<li><p>static 用来修饰的结构：属性、方法; 代码块、内部类；</p>
</li>
<li><p>static修饰属性<br>3.1 复习：变量的分类<br>方式1：按照数据类型：基本数据类型、引用数据类型</p>
<p>方式2：按照类中声明的位置：<br> 成员变量：按照是否使用static修饰进行分类：<br>     使用static修饰的成员变量：静态变量、类变量<br>     不使用static修饰的成员变量：非静态变量、实例变量<br><br> 局部变量：方法内、方法形参、构造器内、构造器形参、代码块内等。<br>3.2 静态变量：类中的属性使用static进行修饰。<br>对比静态变量与实例变量：<br>① 个数<br> &gt;静态变量：在内存空间中只有一份，被类的多个对象所共享。<br> &gt;实例变量：类的每一个实例（或对象）都保存着一份实例变量。<br>② 内存位置<br> &gt;静态变量：jdk6及之前：存放在方法区。 jdk7及之后：存放在堆空间<br> &gt;实例变量：存放在堆空间的对象实体中。<br>③ 加载时机<br> &gt;静态变量：随着类的加载而加载，由于类只会加载一次，所以静态变量也只有一份。<br> &gt;实例变量：随着对象的创建而加载。每个对象拥有一份实例变量。<br>④ 调用者<br> &gt;静态变量：可以被类直接调用，也可以使用对象调用。<br> &gt;实例变量：只能使用对象进行调用。<br>⑤ 判断是否可以调用 —&gt; 从生命周期的角度解释<br>             类变量         实例变量<br> 类            yes            no<br> 对象          yes            yes<br><br>⑥ 消亡时机<br> &gt;静态变量：随着类的卸载而消亡<br> &gt;实例变量：随着对象的消亡而消亡</p>
</li>
<li><p>static修饰方法：（类方法、静态方法）</p>
</li>
</ol>
<blockquote>
<p>随着类的加载而加载<br>可以通过“类.静态方法”的方式，直接调用静态方法<br>静态方法内可以调用静态的属性或静态的方法。（属性和方法的前缀使用的是当前类，可以省略）<br>  不可以调用非静态的结构。（比如：属性、方法）</p>
</blockquote>
<blockquote>
<pre><code>                类方法         实例方法
                        类            yes            no
                        对象          yes            yes
                static修饰的方法内，不能使用this和super
</code></pre>
</blockquote>
<blockquote>
<p>补充：在类的非静态方法中，可以调用当前类中的静态结构（属性、方法）或非静态结构（属性、方法）</p>
</blockquote>
<ol start="5">
<li><p>开发中，什么时候需要将属性声明为静态的？</p>
<blockquote>
<p>判断当前类的多个实例是否能共享此成员变量，且此成员变量的值是相同的。<br>开发中，常将一些常量声明是静态的。比如：Math类中的PI</p>
</blockquote>
<p>什么时候需要将方法声明为静态的？</p>
<blockquote>
<p>方法内操作的变量如果都是静态变量（而非实例变量）的话，则此方法建议声明为静态方法<br>开发中，常常将工具类中的方法，声明为静态方法。比如：Arrays类、Math类</p>
</blockquote>
</li>
</ol>
<h3 id="2-单例-Singleton-设计模式"><a href="#2-单例-Singleton-设计模式" class="headerlink" title="2. 单例(Singleton)设计模式"></a>2. 单例(Singleton)设计模式</h3><p>2.1 设计模式概述</p>
<p><strong>设计模式</strong>是在大量的<code>实践中总结</code>和<code>理论化</code>之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”套路”</p>
<p>经典的设计模式共有23种。每个设计模式均是特定环境下特定问题的处理方法。</p>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220520174508815.png" alt="image-20220520174508815" style="zoom: 80%;" />

<blockquote>
<p>简单工厂模式并不是23中经典模式的一种，是其中工厂方法模式的简化版</p>
</blockquote>
<blockquote>
<p>对软件设计模式的研究造就了一本可能是面向对象设计方面最有影响的书籍：《设计模式》：《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为”四人组（Gang of Four）”，而这本书也就被称为”四人组（或 GoF）”书。</p>
</blockquote>
<p>2.2 何为单例模式</p>
<p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。</p>
<p>2.3 实现思路</p>
<p>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将<code>类的构造器的访问权限设置为private</code>，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，<code>只能调用该类的某个静态方法</code>以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的<code>该类对象的变量也必须定义成静态的</code>。</p>
<p>2.4 单例模式的两种实现方式</p>
<p>2.4.1 饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.4.2 懒汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single;</span><br><span class="line">    <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">null</span>) &#123;</span><br><span class="line">            single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.4.3 饿汉式 vs 懒汉式</p>
<p>饿汉式：</p>
<ul>
<li>特点：<code>立即加载</code>，即在使用类的时候已经将对象创建完毕。</li>
<li>优点：实现起来<code>简单</code>；没有多线程安全问题。</li>
<li>缺点：当类被加载的时候，会初始化static的实例，静态变量被创建并分配内存空间，从这以后，这个static的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会<code>耗费内存</code>。</li>
</ul>
<p>懒汉式：</p>
<ul>
<li>特点：<code>延迟加载</code>，即在调用静态方法时实例才被创建。</li>
<li>优点：实现起来比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会<code>节约内存</code>。</li>
<li>缺点：在多线程环境中，这种实现方法是完全错误的，<code>线程不安全</code>，根本不能保证单例的唯一性。<ul>
<li>说明：在多线程章节，会将懒汉式改造成线程安全的模式。</li>
</ul>
</li>
</ul>
<p>2.5 单例模式的优点及应用场景</p>
<p>由于单例模式只生成一个实例，减少了<code>系统性能开销</code>，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</p>
<p>举例：</p>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220325222541203.png" alt="image-20220325222541203" style="zoom:67%;" />

<p><strong>应用场景</strong></p>
<ul>
<li><p>Windows的Task Manager (任务管理器)就是很典型的单例模式</p>
</li>
<li><p>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</p>
</li>
<li><p>Application 也是单例的典型应用</p>
</li>
<li><p>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只</p>
<p>能有一个实例去操作，否则内容不好追加。</p>
</li>
<li><p>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</p>
</li>
</ul>
<p>总结：</p>
<ol>
<li>设计模式概述：<br>设计模式是在大量的<code>实践中总结</code>和<code>理论化</code>之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。<br>就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”套路”</li>
</ol>
<p>经典的设计模式一共有23种。</p>
<ol start="2">
<li><p>何为单例模式(Singleton)：<br>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</p>
</li>
<li><p>如何实现单例模式（掌握）:</p>
</li>
</ol>
<blockquote>
<p>饿汉式</p>
</blockquote>
<blockquote>
<p>懒汉式</p>
</blockquote>
<ol start="4">
<li>对比两种模式（特点、优缺点）<br>特点：</li>
</ol>
<blockquote>
<p>饿汉式：“立即加载”,随着类的加载，当前的唯一实例就创建了<br>懒汉式：”延迟加载”,在需要使用的时候，进行创建。</p>
</blockquote>
<p>优缺点：</p>
<blockquote>
<p>饿汉式：（优点）写法简单，由于内存中较早加载，使用更方便、更快。是线程安全的。 （缺点）内存中占用时间较长。<br>懒汉式：（缺点）线程不安全 （放到多线程章节时解决）（优点）在需要的时候进行创建，节省内存空间。</p>
</blockquote>
<h3 id="3-理解main方法的语法"><a href="#3-理解main方法的语法" class="headerlink" title="3. 理解main方法的语法"></a>3. 理解main方法的语法</h3><p>由于JVM需要调用类的main()方法，所以该方法的访问权限必须是public，又因为JVM在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。 </p>
<p>又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。</p>
<p><strong>命令行参数用法举例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandPara</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;args[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行程序CommandPara.java</span></span><br><span class="line">java CommandPara <span class="string">&quot;Tom&quot;</span> <span class="string">&quot;Jerry&quot;</span> <span class="string">&quot;Shkstart&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">args[<span class="number">0</span>] = Tom</span><br><span class="line">args[<span class="number">1</span>] = Jerry</span><br><span class="line">args[<span class="number">2</span>] = Shkstart</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220325223215924.png" alt="image-20220325223215924"></p>
<p>IDEA工具：</p>
<p>（1）配置运行参数</p>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20211228101828718.png" alt="image-20211228101828718" style="zoom: 80%;" />

<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20211228102022216.png" alt="image-20211228102022216" style="zoom:67%;" />

<p>（2）运行程序</p>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20211228102059327.png" alt="image-20211228102059327" style="zoom: 80%;" />

<p>总结：</p>
<p>main()方法的剖析<br>public static void main(String args[]){}</p>
<ol>
<li><p>理解1：看做是一个普通的静态方法<br>理解2：看做是程序的入口，格式是固定的。</p>
</li>
<li><p>与控制台交互<br>如何从键盘获取数据？</p>
</li>
</ol>
<blockquote>
<p>方式1：使用Scanner<br>方式2：使用main()的形参进行传值。</p>
</blockquote>
<h3 id="4-类的成员之四：代码块"><a href="#4-类的成员之四：代码块" class="headerlink" title="4. 类的成员之四：代码块"></a>4. 类的成员之四：代码块</h3><p>如果成员变量想要初始化的值不是一个硬编码的常量值，而是需要通过复杂的计算或读取文件、或读取运行环境信息等方式才能获取的一些值，该怎么办呢？此时，可以考虑代码块（或初始化块）。</p>
<ul>
<li><p>代码块(或初始化块)的<code>作用</code>：</p>
</li>
<li><p>对Java类或对象进行初始化</p>
</li>
<li><p>代码块(或初始化块)的<code>分类</code>：</p>
<ul>
<li><p>一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)</p>
</li>
<li><p>没有使用static修饰的，为非静态代码块。</p>
</li>
</ul>
</li>
</ul>
<p>4.1 静态代码块</p>
<p>如果想要为静态变量初始化，可以直接在静态变量的声明后面直接赋值，也可以使用静态代码块。</p>
<p>4.1.1 语法格式</p>
<p>在代码块的前面加static，就是静态代码块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 类&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">        静态代码块</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.1.2 静态代码块的特点</p>
<ol>
<li><p>可以有输出语句。</p>
</li>
<li><p>可以对类的属性、类的声明进行初始化操作。</p>
</li>
<li><p>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</p>
</li>
<li><p>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</p>
</li>
<li><p>静态代码块的执行要先于非静态代码块。</p>
</li>
<li><p>静态代码块随着类的加载而加载，且只执行一次。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chinese</span> &#123;</span><br><span class="line"><span class="comment">//    private static String country = &quot;中国&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String country;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非静态代码块，country = &quot;</span> + country);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        country = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStaticBlock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.2 非静态代码块</p>
<p>4.2.1 语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 类&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        非静态代码块</span><br><span class="line">    &#125;</span><br><span class="line">    【修饰符】 构造器名()&#123;</span><br><span class="line">    	<span class="comment">// 实例初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    【修饰符】 构造器名(参数列表)&#123;</span><br><span class="line">        <span class="comment">// 实例初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.2.2 非静态代码块的作用</p>
<p>和构造器一样，也是用于实例变量的初始化等操作。</p>
<p>4.2.3 非静态代码块的意义</p>
<p>如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执行的，那么可以将这部分代码抽取到非静态代码块中，减少冗余代码。</p>
<p>4.2.4 非静态代码块的执行特点</p>
<ol>
<li><p>可以有输出语句。</p>
</li>
<li><p>可以对类的属性、类的声明进行初始化操作。</p>
</li>
<li><p>除了调用非静态的结构外，还可以调用静态的变量或方法。</p>
</li>
<li><p>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</p>
</li>
<li><p>每次创建对象的时候，都会执行一次。且先于构造器执行。</p>
</li>
</ol>
<p>4.3 举例</p>
<p><strong>举例1：</strong></p>
<p>（1）声明User类，</p>
<ul>
<li><p>包含属性：username（String类型），password（String类型），registrationTime（long类型），私有化</p>
</li>
<li><p>包含get&#x2F;set方法，其中registrationTime没有set方法</p>
</li>
<li><p>包含无参构造，</p>
<ul>
<li>输出“新用户注册”，</li>
<li>registrationTime赋值为当前系统时间，</li>
<li>username就默认为当前系统时间值，</li>
<li>password默认为“123456”</li>
</ul>
</li>
<li><p>包含有参构造(String username, String password)，</p>
<ul>
<li>输出“新用户注册”，</li>
<li>registrationTime赋值为当前系统时间，</li>
<li>username和password由参数赋值</li>
</ul>
</li>
<li><p>包含public String getInfo()方法，返回：“用户名：xx，密码：xx，注册时间：xx”</p>
</li>
</ul>
<p>（2）编写测试类，测试类main方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    System.out.println(u1.getInfo());</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;song&quot;</span>,<span class="string">&quot;8888&quot;</span>);</span><br><span class="line">    System.out.println(u2.getInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不用非静态代码块，User类是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.block.no;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> registrationTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新用户注册&quot;</span>);</span><br><span class="line">        registrationTime = System.currentTimeMillis();</span><br><span class="line">        username = registrationTime+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String username,String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新用户注册&quot;</span>);</span><br><span class="line">        registrationTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getRegistrationTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名：&quot;</span> + username + <span class="string">&quot;，密码：&quot;</span> + password + <span class="string">&quot;，注册时间：&quot;</span> + registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果提取构造器公共代码到非静态代码块，User类是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.block.use;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> registrationTime;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新用户注册&quot;</span>);</span><br><span class="line">        registrationTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        username = registrationTime+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getRegistrationTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名：&quot;</span> + username + <span class="string">&quot;，密码：&quot;</span> + password + <span class="string">&quot;，注册时间：&quot;</span> + registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>举例2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		is = DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line">		<span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">		pros.load(is);</span><br><span class="line">		<span class="comment">//调用BasicDataSourceFactory的静态方法，获取数据源。</span></span><br><span class="line">		dataSource = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				is.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.4 小结：实例变量赋值顺序</p>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220325230208941.png" alt="image-20220325230208941" style="zoom:67%;" />



<p>代码块总结：</p>
<p>类的成员之四：代码块</p>
<p>回顾：类中可以声明的结构：属性、方法、构造器；代码块（或初始化块）、内部类</p>
<ol>
<li><p>代码块（或初始化块）的作用：<br>用来初始化类或对象的信息（即初始化类或对象的成员变量）</p>
</li>
<li><p>代码块的修饰：<br>只能使用static进行修饰。</p>
</li>
<li><p>代码块的分类：<br>静态代码块：使用static修饰<br>非静态代码块：没有使用static修饰</p>
</li>
<li><p>具体使用：<br>4.1 静态代码块：</p>
<blockquote>
<p>随着类的加载而执行<br>由于类的加载只会执行一次，进而静态代码块的执行，也只会执行一次<br>作用：用来初始化类的信息<br>内部可以声明变量、调用属性或方法、编写输出语句等操作。<br>静态代码块的执行要先于非静态代码块的执行<br>如果声明有多个静态代码块，则按照声明的先后顺序执行<br>静态代码块内部只能调用静态的结构（即静态的属性、方法），不能调用非静态的结构（即非静态的属性、方法）</p>
</blockquote>
</li>
</ol>
<p>4.2 非静态代码块：<br>    &gt; 随着对象的创建而执行<br>    &gt; 每创建当前类的一个实例，就会执行一次非静态代码块<br>    &gt; 作用：用来初始化对象的信息<br>    &gt; 内部可以声明变量、调用属性或方法、编写输出语句等操作。<br>    &gt; 如果声明有多个非静态代码块，则按照声明的先后顺序执行<br>    &gt; 非静态代码块内部可以调用静态的结构（即静态的属性、方法），也可以调用非静态的结构（即非静态的属性、方法）</p>
<p>总结：</p>
<p>​	属性赋值过程</p>
<ol>
<li>可以给类的非静态的属性（即实例变量）赋值的位置有：<br>① 默认初始化<br>② 显式初始化  或 ⑤ 代码块中初始化<br>③ 构造器中初始化</li>
</ol>
<hr>
<p>④ 有了对象以后，通过”对象.属性”或”对象.方法”的方法进行赋值</p>
<ol start="2">
<li><p>执行的先后顺序：<br>① - ②&#x2F;⑤ - ③ - ④</p>
</li>
<li><p>(超纲)关于字节码文件中的<init>的简单说明：(通过插件jclasslib bytecode viewer查看)</p>
</li>
</ol>
<blockquote>
<p><init>方法在字节码文件中可以看到。每个<init>方法都对应着一个类的构造器。（类中声明了几个构造器就会有几个<init>）<br>编写的代码中的构造器在编译以后就会以<init>方法的方式呈现<br><init>方法内部的代码包含了实例变量的显示赋值、代码块中的赋值和构造器中的代码。<br><init>方法用来初始化当前创建的对象的信息的。</p>
</blockquote>
<ol start="4">
<li>给实例变量赋值的位置很多，开发中如何选？</li>
</ol>
<blockquote>
<p>显示赋值：比较适合于每个对象的属性值相同的场景</p>
</blockquote>
<blockquote>
<p>构造器中赋值：比较适合于每个对象的属性值不相同的场景</p>
</blockquote>
<h3 id="5-final关键字"><a href="#5-final关键字" class="headerlink" title="5. final关键字"></a>5. final关键字</h3><p>5.1 final的意义</p>
<p>final：最终的，不可更改的</p>
<p>5.2 final的使用</p>
<p>5.2.1 final修饰类</p>
<p>表示这个类不能被继承，没有子类。提高安全性，提高程序的可读性。</p>
<p>例如：String类、System类、StringBuffer类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Eunuch</span>&#123;<span class="comment">//太监类</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Eunuch</span>&#123;<span class="comment">//错误</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.2.2 final修饰方法</p>
<p>表示这个方法不能被子类重写。</p>
<p>例如：Object类中的getClass()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;<span class="comment">//错误</span></span><br><span class="line">		System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.2.3 final修饰变量</p>
<p>final修饰某个变量（成员变量或局部变量），一旦赋值，它的值就不能被修改，即常量，常量名建议使用大写字母。</p>
<p>例如：final double MY_PI &#x3D; 3.14;</p>
<blockquote>
<p>如果某个成员变量用final修饰后，没有set方法，并且必须初始化（可以显式赋值、或在初始化块赋值、实例变量还可以在构造器中赋值）</p>
</blockquote>
<ul>
<li>修饰成员变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">totalNumber</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        ID = ++totalNumber; <span class="comment">// 可在构造器中给final修饰的“变量”赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(t.ID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>修饰局部变量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> MIN_SCORE ;</span><br><span class="line">        MIN_SCORE = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SCORE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        MAX_SCORE = <span class="number">200</span>; <span class="comment">//非法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>错误演示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INFO</span> <span class="operator">=</span> <span class="string">&quot;atguigu&quot;</span>;  <span class="comment">//声明常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//The final field A.INFO cannot be  assigned</span></span><br><span class="line">        <span class="comment">//INFO = &quot;尚硅谷&quot;; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>final关键字的使用</p>
<ol>
<li><p>final的理解：最终的</p>
</li>
<li><p>final可以用来修饰的结构：类、方法、变量</p>
</li>
<li><p>具体说明：</p>
</li>
</ol>
<p>3.1 final修饰类：表示此类不能被继承。<br>    比如：String、StringBuffer、StringBuilder类</p>
<p>3.2 final修饰方法：表示此方法不能被重写<br>    比如：Object类中的getClass()</p>
<p>3.3 final修饰变量：既可以修饰成员变量，也可以修饰局部变量。<br>    此时的”变量”其实就变成了”常量”，意味着一旦赋值，就不可更改。</p>
<pre><code>3.3.1 final修饰成员变量: 有哪些位置可以给成员变量赋值？
    &gt; 显式赋值
    &gt; 代码块中赋值
    &gt; 构造器中赋值
</code></pre>
<p>   3.3.2 final修饰局部变量：一旦赋值就不能修改<br>        &gt; 方法内声明的局部变量：在调用局部变量前，一定需要赋值。而且一旦赋值，就不可更改<br>        &gt; 方法的形参：在调用此方法时，给形参进行赋值。而且一旦赋值，就不可更改</p>
<ol start="4">
<li>final与static搭配：修饰成员变量时，此成员变量称为：全局常量。<br>比如：Math的PI</li>
</ol>
<h3 id="6-抽象类与抽象方法-或abstract关键字"><a href="#6-抽象类与抽象方法-或abstract关键字" class="headerlink" title="6. 抽象类与抽象方法(或abstract关键字)"></a>6. 抽象类与抽象方法(或abstract关键字)</h3><ol start="6">
<li>1语法格式</li>
</ol>
<ul>
<li><strong>抽象类</strong>：被abstract修饰的类。</li>
<li><strong>抽象方法</strong>：被abstract修饰没有方法体的方法。</li>
</ul>
<p>抽象类的语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[权限修饰符] <span class="keyword">abstract</span> class 类名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">[权限修饰符] <span class="keyword">abstract</span> class 类名 extends 父类&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象方法的语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[其他修饰符] <span class="keyword">abstract</span> 返回值类型 方法名([形参列表]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：抽象方法没有方法体</p>
</blockquote>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220517204707255.png" alt="image-20220517204707255"></p>
<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span> <span class="params">()</span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;小猫吃鱼和猫粮&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CatTest</span> &#123;</span><br><span class="line"> 	 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); </span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 调用eat方法</span></span><br><span class="line">        c.eat();</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p>
<p>6.2 使用说明</p>
<ol>
<li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p>
<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
<p>抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p>
</blockquote>
</li>
<li><p>抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。</p>
<blockquote>
<p>理解：子类的构造方法中，有默认的super()或手动的super(实参列表)，需要访问父类构造方法。</p>
</blockquote>
</li>
<li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
</li>
<li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 </p>
<blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
</li>
</ol>
<p>6.3 注意事项</p>
<ul>
<li><p>不能用abstract修饰变量、代码块、构造器；</p>
</li>
<li><p>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</p>
</li>
</ul>
<p>6.4 应用举例1</p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220325232847872.png" alt="image-20220325232847872"></p>
<p>在航运公司系统中，Vehicle类需要定义两个方法分别<code>计算运输工具的燃料效率</code>和<code>行驶距离</code>。</p>
<p><strong>问题：</strong>卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不同。Vehicle类不能提供计算方法，但子类可以。</p>
<p><strong>解决方案：</strong>Java允许类设计者指定：超类声明一个方法但不提供实现，该方法的实现由子类提供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vehicle是一个抽象类，有两个抽象方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">()</span>;	<span class="comment">//计算燃料效率的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">()</span>;	<span class="comment">//计算行驶距离的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Truck</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">( )</span>   &#123; <span class="comment">//写出计算卡车的燃料效率的具体方法   &#125;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">( )</span>    &#123;  <span class="comment">//写出计算卡车行驶距离的具体方法   &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiverBarge</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">	 <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">( )</span> &#123; <span class="comment">//写出计算驳船的燃料效率的具体方法  &#125;</span></span><br><span class="line">	 <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">( )</span>  &#123;  <span class="comment">//写出计算驳船行驶距离的具体方法&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.5 应用举例2：模板方法设计模式(TemplateMethod)</p>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<p><strong>解决的问题</strong>：</p>
<ul>
<li><p>当功能内部一部分实现是确定的，另一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p>
</li>
<li><p>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p>
</li>
</ul>
<p><strong>类比举例：</strong>英语六级模板</p>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220503145003315.png" alt="image-20220503145003315" style="zoom: 80%;" />

<p>制作月饼的模板：</p>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220517205013997.png" alt="image-20220517205013997" style="zoom: 50%;" />

<p>举例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        code();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间是：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java;</span><br><span class="line"><span class="comment">//抽象类的应用：模板方法的设计模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateMethodTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">BankTemplateMethod</span> <span class="variable">btm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DrawMoney</span>();</span><br><span class="line">		btm.process();</span><br><span class="line"></span><br><span class="line">		<span class="type">BankTemplateMethod</span> <span class="variable">btm2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ManageMoney</span>();</span><br><span class="line">		btm2.process();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BankTemplateMethod</span> &#123;</span><br><span class="line">	<span class="comment">// 具体方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeNumber</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;取号排队&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">transact</span><span class="params">()</span>; <span class="comment">// 办理具体的业务 //钩子方法</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evaluate</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;反馈评分&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模板方法，把基本操作组合到一起，子类一般不能重写</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.takeNumber();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.transact();<span class="comment">// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.evaluate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawMoney</span> <span class="keyword">extends</span> <span class="title class_">BankTemplateMethod</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transact</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要取款！！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ManageMoney</span> <span class="keyword">extends</span> <span class="title class_">BankTemplateMethod</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transact</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我要理财！我这里有2000万美元!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p>
<ul>
<li><p>数据库访问的封装</p>
</li>
<li><p>Junit单元测试</p>
</li>
<li><p>JavaWeb的Servlet中关于doGet&#x2F;doPost方法调用</p>
</li>
<li><p>Hibernate中模板程序</p>
</li>
<li><p>Spring中JDBCTemlate、HibernateTemplate等</p>
</li>
</ul>
<p>总结：</p>
<p>抽象类与抽象方法</p>
<ol>
<li>案例引入<br>举例1：GeometricObject-Circle-Rectangle</li>
</ol>
<p>abstract class GeometricObject{  &#x2F;&#x2F;几何图形</p>
<pre><code>//求面积 （只能考虑提供方法的声明，而没有办法提供方法体。所以，此方法适合声明为抽象方法）

//求周长（只能考虑提供方法的声明，而没有办法提供方法体。所以，此方法适合声明为抽象方法）
</code></pre>
<p>}</p>
<p>class Circle extends GeometricObject{</p>
<pre><code>//求面积 （必须重写（或实现）父类中的抽象方法）

//求周长（必须重写（或实现）父类中的抽象方法）
</code></pre>
<p>}</p>
<p>class Rectangle extends GeometricObject{</p>
<pre><code>//求面积 （必须重写（或实现）父类中的抽象方法）

//求周长（必须重写（或实现）父类中的抽象方法）
</code></pre>
<p>}</p>
<p>举例2：Account-SavingAccount-CheckAcount</p>
<p>abstract class Account{</p>
<pre><code>double balance;//余额

//取钱 （声明为抽象方法）

//存钱 （声明为抽象方法）
</code></pre>
<p>}</p>
<p>class SavingAccount extends Account{ &#x2F;&#x2F;储蓄卡<br>    &#x2F;&#x2F;取钱 （需要重写父类中的抽象方法）</p>
<pre><code>//存钱（需要重写父类中的抽象方法）
</code></pre>
<p>}<br>class CheckAccount extends Account{ &#x2F;&#x2F;信用卡<br>    &#x2F;&#x2F;取钱（需要重写父类中的抽象方法）</p>
<pre><code>//存钱（需要重写父类中的抽象方法）
</code></pre>
<p>}<br>&#x2F;&#x2F;….</p>
<ol start="2">
<li><p>abstract的概念：抽象的</p>
</li>
<li><p>abstract可以用来修饰：类、方法</p>
</li>
<li><p>具体的使用：</p>
</li>
</ol>
<p>4.1 abstract修饰类：<br>    &gt; 此类称为抽象类<br>    &gt; 抽象类不能实例化。<br>    &gt; 抽象类中是包含构造器的，因为子类对象实例化时，需要直接或间接的调用到父类的构造器。<br>    &gt; 抽象类中可以没有抽象方法。反之，抽象方法所在的类，一定是抽象类。</p>
<p>4.2 abstract修饰方法：<br>    &gt; 此方法即为抽象方法<br>    &gt; 抽象方法只有方法的声明，没有方法体。<br>    &gt; 抽象方法其功能是确定的（通过方法的声明即可确定），只是不知道如何具体实现（体现为没有方法体）<br>    &gt; 子类必须重写父类中的所有的抽象方法之后，方可实例化。否则，此子类仍然是一个抽象类。</p>
<ol start="5">
<li>abstract不能使用的场景：<br>5.1 abstract 不能修饰哪些结构？<br>属性、构造器、代码块等。</li>
</ol>
<p>5.2 abstract 不能与哪些关键字共用？（自洽）</p>
<p>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</p>
<blockquote>
<p>私有方法不能重写<br>避免静态方法使用类进行调用<br>final的方法不能被重写<br>final修饰的类不能有子类</p>
</blockquote>
<h3 id="7-接口-interface"><a href="#7-接口-interface" class="headerlink" title="7. 接口(interface)"></a>7. 接口(interface)</h3><p>7.1 类比</p>
<p>生活中大家每天都在用USB接口，那么USB接口与我们今天要学习的接口有什么相同点呢？</p>
<pre><code> USB，（Universal Serial Bus，通用串行总线）是Intel公司开发的总线架构，使得在计算机上添加串行设备（鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等）非常容易。
</code></pre>
<p>其实，不管是电脑上的USB插口，还是其他设备上的USB插口都只是<code>遵循了USB规范</code>的一种具体设备而已。</p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/bbcc80f541000c71b81650cfaa770c86.png" alt="bbcc80f541000c71b81650cfaa770c86"></p>
<p>只要设备遵循USB规范的，那么就可以与电脑互联，并正常通信。至于这个设备、电脑是哪个厂家制造的，内部是如何实现的，我们都无需关心。</p>
<p>Java的软件系统会有很多模块组成，那么各个模块之间也应该采用这种<code>面向接口</code>的<code>低耦合</code>，为系统提供更好的可扩展性和可维护性。</p>
<p>7.2 概述</p>
<p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是&#x2F;要…则必须能…”的思想。继承是一个”是不是”的is-a关系，而接口实现则是 “能不能”的<code>has-a</code>关系。</p>
<ul>
<li>例如：电脑都预留了可以插入USB设备的USB接口，USB接口具备基本的数据传输的开启功能和关闭功能。你能不能用USB进行连接，或是否具备USB通信功能，就看你能否遵循USB接口规范</li>
</ul>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220517211517846.png" alt="image-20220517211517846" style="zoom:67%;" />

<ul>
<li>例如：Java程序是否能够连接使用某种数据库产品，那么要看该数据库产品能否实现Java设计的JDBC规范</li>
</ul>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220325235434103.png" alt="image-20220325235434103" style="zoom:67%;" />



<blockquote>
<p>接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。</p>
</blockquote>
<p>7.3 定义格式</p>
<p>接口的定义，它与定义类方式相似，但是使用 <code>interface</code> 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p>
<blockquote>
<p>引用数据类型：数组，类，枚举，接口，注解。</p>
</blockquote>
<p>7.3.1 接口的声明格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] interface 接口名&#123;</span><br><span class="line">    <span class="comment">//接口的成员列表：</span></span><br><span class="line">    <span class="comment">// 公共的静态常量</span></span><br><span class="line">    <span class="comment">// 公共的抽象方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公共的默认方法（JDK1.8以上）</span></span><br><span class="line">    <span class="comment">// 公共的静态方法（JDK1.8以上）</span></span><br><span class="line">    <span class="comment">// 私有方法（JDK1.9以上）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB3</span>&#123;</span><br><span class="line">    <span class="comment">//静态常量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">500</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">//500MB/s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;USB 3.0可以同步全速地进行读写操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.3.2 接口的成员说明</p>
<p><strong>在JDK8.0 之前</strong>，接口中只允许出现：</p>
<p>（1）公共的静态的常量：其中<code>public static final</code>可以省略</p>
<p>（2）公共的抽象的方法：其中<code>public abstract</code>可以省略</p>
<blockquote>
<p>理解：接口是从多个相似类中抽象出来的规范，不需要提供具体实现</p>
</blockquote>
<p><strong>在JDK8.0 时</strong>，接口中允许声明<code>默认方法</code>和<code>静态方法</code>：</p>
<p>（3）公共的默认的方法：其中public 可以省略，建议保留，但是default不能省略</p>
<p>（4）公共的静态的方法：其中public 可以省略，建议保留，但是static不能省略</p>
<p><strong>在JDK9.0 时</strong>，接口又增加了：</p>
<p>（5）私有方法</p>
<p>除此之外，接口中没有构造器，没有初始化块，因为接口中没有成员变量需要动态初始化。</p>
<p>7.4 接口的使用规则</p>
<p><strong>1、类实现接口（implements）</strong></p>
<p>接口<strong>不能创建对象</strong>，但是可以被类实现（<code>implements</code> ，类似于被继承）。</p>
<p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code> implements</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 实现类  implements 接口&#123;</span><br><span class="line">	<span class="comment">// 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  	<span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 class 实现类 extends 父类 implements 接口&#123;</span><br><span class="line">    <span class="comment">// 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  	<span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220514163212312.png" alt="image-20220514163212312" style="zoom:80%;" />

<p>注意：</p>
<ol>
<li><p>如果接口的实现类是非抽象类，那么必须<code>重写接口中所有抽象方法</code>。</p>
</li>
<li><p>默认方法可以选择保留，也可以重写。</p>
<blockquote>
<p>重写时，default单词就不要再写了，它只用于在接口中表示默认方法，到类中就没有默认方法的概念了</p>
</blockquote>
</li>
<li><p>接口中的静态方法不能被继承也不能被重写</p>
</li>
</ol>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;		<span class="comment">// </span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> ;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> ;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(USB usb)</span>&#123;	</span><br><span class="line">		usb.start() ;</span><br><span class="line">		System.out.println(<span class="string">&quot;=========== USB 设备工作 ========&quot;</span>) ;</span><br><span class="line">		usb.stop() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flash</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;	<span class="comment">// 重写方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;U盘开始工作。&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;		<span class="comment">// 重写方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;U盘停止工作。&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;	<span class="comment">// 重写方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;打印机开始工作。&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;		<span class="comment">// 重写方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;打印机停止工作。&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">		Computer.show(<span class="keyword">new</span> <span class="title class_">Flash</span>()) ;</span><br><span class="line">		Computer.show(<span class="keyword">new</span> <span class="title class_">Print</span>()) ;</span><br><span class="line"></span><br><span class="line">		c.show(<span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;移动硬盘开始运行&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;移动硬盘停止运行&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2、接口的多实现（implements）</strong></p>
<p>之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的<code>多实现</code>。并且，一个类能继承一个父类，同时实现多个接口。</p>
<p>实现格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 实现类  implements 接口<span class="number">1</span>，接口<span class="number">2</span>，接口<span class="number">3</span>。。。&#123;</span><br><span class="line">	<span class="comment">// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  	<span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 class 实现类 extends 父类 implements 接口<span class="number">1</span>，接口<span class="number">2</span>，接口<span class="number">3</span>。。。&#123;</span><br><span class="line">    <span class="comment">// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  	<span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接口中，有多个抽象方法时，实现类必须重写所有抽象方法。<strong>如果抽象方法有重名的，只需要重写一次</strong>。</p>
</blockquote>
<p>举例：</p>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220514163311418.png" alt="image-20220514163311418" style="zoom:80%;" />

<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220325235321778.png" alt="image-20220325235321778" style="zoom:67%;" />

<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/1562216188519.png" alt="1562216188519"></p>
<p>定义多个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span>,B &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;showA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;showB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.showA();</span><br><span class="line">        c.showB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、接口的多继承(extends)</strong></p>
<p>一个接口能继承另一个或者多个接口，接口的继承也使用 <code>extends</code> 关键字，子接口继承父接口的方法。</p>
<p>定义父接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Chargeable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义子接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UsbC</span> <span class="keyword">extends</span> <span class="title class_">Chargeable</span>,USB3 &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义子接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeCConverter</span> <span class="keyword">implements</span> <span class="title class_">UsbC</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正反面都支持&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;可充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输出数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有父接口的抽象方法都有重写。</p>
<p>方法签名相同的抽象方法只需要实现一次。</p>
</blockquote>
<p><strong>4、接口与实现类对象构成多态引用</strong></p>
<p>实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你new的实现类对象实现的方法体。</p>
<p>接口的不同实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">USB3</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送脉冲信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不接收信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeyBoard</span> <span class="keyword">implements</span> <span class="title class_">USB3</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不接收信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送按键信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestComputer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">USB3</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">        computer.setUsb(usb);</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.out();</span><br><span class="line">        usb.in();</span><br><span class="line">        usb.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        usb = <span class="keyword">new</span> <span class="title class_">KeyBoard</span>();</span><br><span class="line">        computer.setUsb(usb);</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.out();</span><br><span class="line">        usb.in();</span><br><span class="line">        usb.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        usb = <span class="keyword">new</span> <span class="title class_">MobileHDD</span>();</span><br><span class="line">        computer.setUsb(usb);</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.out();</span><br><span class="line">        usb.in();</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5、使用接口的静态成员</strong></p>
<p>接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUSB3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过“接口名.”调用接口的静态方法 (JDK8.0才能开始使用)</span></span><br><span class="line">        USB3.show();</span><br><span class="line">        <span class="comment">//通过“接口名.”直接使用接口的静态常量</span></span><br><span class="line">        System.out.println(USB3.MAX_SPEED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6、使用接口的非静态方法</strong></p>
<ul>
<li>对于接口的静态方法，直接使用“<code>接口名.</code>”进行调用即可<ul>
<li>也只能使用“接口名.”进行调用，不能通过实现类的对象进行调用</li>
</ul>
</li>
<li>对于接口的抽象方法、默认方法，只能通过实现类对象才可以调用<ul>
<li>接口不能直接创建对象，只能创建实现类的对象</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMobileHDD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建实现类对象</span></span><br><span class="line">        <span class="type">MobileHDD</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MobileHDD</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过实现类对象调用重写的抽象方法，以及接口的默认方法，如果实现类重写了就执行重写的默认方法，如果没有重写，就执行接口中的默认方法</span></span><br><span class="line">        b.start();</span><br><span class="line">        b.in();</span><br><span class="line">        b.stop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过接口名调用接口的静态方法</span></span><br><span class="line"><span class="comment">//        MobileHDD.show();</span></span><br><span class="line"><span class="comment">//        b.show();</span></span><br><span class="line">        Usb3.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.5 JDK8中相关冲突问题</p>
<p>7.5.1 默认方法冲突问题</p>
<p><strong>（1）类优先原则</strong></p>
<p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。代码如下：</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span>&#123;<span class="comment">//约会</span></span><br><span class="line">        System.out.println(<span class="string">&quot;吃喝玩乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span>&#123;<span class="comment">//约会</span></span><br><span class="line">        System.out.println(<span class="string">&quot;爸爸约吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> <span class="keyword">implements</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//(1)不重写默认保留父类的</span></span><br><span class="line">        <span class="comment">//(2)调用父类被重写的</span></span><br><span class="line"><span class="comment">//        super.date();</span></span><br><span class="line">        <span class="comment">//(3)保留父接口的</span></span><br><span class="line"><span class="comment">//        Friend.super.date();</span></span><br><span class="line">        <span class="comment">//(4)完全重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;跟康师傅学Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        s.date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）接口冲突（左右为难）</strong></p>
<ul>
<li>当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？</li>
</ul>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/选择困难.jpg"></p>
<p>无论你多难抉择，最终都是要做出选择的。</p>
<p>声明接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BoyFriend</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span>&#123;<span class="comment">//约会</span></span><br><span class="line">        System.out.println(<span class="string">&quot;神秘约会&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择保留其中一个，通过“<code>接口名.super.方法名</code>“的方法选择保留哪个接口的默认方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">Friend</span>,BoyFriend&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//(1)保留其中一个父接口的</span></span><br><span class="line"><span class="comment">//        Friend.super.date();</span></span><br><span class="line"><span class="comment">//        BoyFriend.super.date();</span></span><br><span class="line">        <span class="comment">//(2)完全重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;跟康师傅学Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGirl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">        girl.date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？</li>
</ul>
<p>另一个父接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB2</span> &#123;</span><br><span class="line">    <span class="comment">//静态常量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">60</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">//60MB/s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;USB 2.0可以高速地进行读写操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB</span> <span class="keyword">extends</span> <span class="title class_">USB2</span>,USB3 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Usb.start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Usb.stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>子接口重写默认方法时，default关键字可以保留。</p>
<p>子类重写默认方法时，default关键字不可以保留。</p>
</blockquote>
<p>7.5.2 常量冲突问题</p>
<ul>
<li>当子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。</li>
<li>当子类同时实现多个接口，而多个接口存在相同同名常量。</li>
</ul>
<p>此时在子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突问题。</p>
<p>父类和父接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SuperInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MotherInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> <span class="keyword">implements</span> <span class="title class_">SuperInterface</span>,MotherInterface &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;x = &quot; + x);//模糊不清</span></span><br><span class="line">        System.out.println(<span class="string">&quot;super.x = &quot;</span> + <span class="built_in">super</span>.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperInterface.x = &quot;</span> + SuperInterface.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;MotherInterface.x = &quot;</span> + MotherInterface.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;y = &quot;</span> + y);<span class="comment">//没有重名问题，可以直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.6 接口的总结与面试题</p>
<ul>
<li>接口本身不能创建对象，只能创建接口的实现类对象，接口类型的变量可以与实现类对象构成多态引用。</li>
<li>声明接口用interface，接口的成员声明有限制：<ul>
<li>（1）公共的静态常量</li>
<li>（2）公共的抽象方法</li>
<li>（3）公共的默认方法（JDK8.0 及以上）</li>
<li>（4）公共的静态方法（JDK8.0 及以上）</li>
<li>（5）私有方法（JDK9.0 及以上）</li>
</ul>
</li>
<li>类可以实现接口，关键字是implements，而且支持多实现。如果实现类不是抽象类，就必须实现接口中所有的抽象方法。如果实现类既要继承父类又要实现父接口，那么继承（extends）在前，实现（implements）在后。</li>
<li>接口可以继承接口，关键字是extends，而且支持多继承。</li>
<li>接口的默认方法可以选择重写或不重写。如果有冲突问题，另行处理。子类重写父接口的默认方法，要去掉default，子接口重写父接口的默认方法，不要去掉default。</li>
<li>接口的静态方法不能被继承，也不能被重写。接口的静态方法只能通过“接口名.静态方法名”进行调用。</li>
</ul>
<p><strong>面试题</strong></p>
<p><strong>1、为什么接口中只能声明公共的静态的常量？</strong></p>
<p>因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则就有“危险”。</p>
<p>例如：USB1.0规范中规定最大传输速率是1.5Mbps，最大输出电流是5V&#x2F;500mA</p>
<p>​           USB3.0规范中规定最大传输速率是5Gbps(500MB&#x2F;s)，最大输出电流是5V&#x2F;900mA</p>
<p>例如：尚硅谷学生行为规范中规定学员，早上8:25之前进班，晚上21:30之后离开等等。</p>
<p><strong>2、为什么JDK8.0 之后允许接口定义静态方法和默认方法呢？因为它违反了接口作为一个抽象标准定义的概念。</strong></p>
<p><code>静态方法</code>：因为之前的标准类库设计中，有很多Collection&#x2F;Colletions或者Path&#x2F;Paths这样成对的接口和类，后面的类中都是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对API，不如把静态方法直接定义到接口中使用和维护更方便。</p>
<p><code>默认方法</code>：（1）我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有问题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8中对Collection、List、Comparator等接口提供了丰富的默认方法。（2）当我们接口的某个抽象方法，在很多实现类中的实现代码是一样的，此时将这个抽象方法设计为默认方法更为合适，那么实现类就可以选择重写，也可以选择不重写。</p>
<p><strong>3、为什么JDK1.9要允许接口定义私有方法呢？因为我们说接口是规范，规范是需要公开让大家遵守的。</strong></p>
<p><strong>私有方法</strong>：因为有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法由共同的代码可以抽取，而这些共同的代码抽取出来的方法又只希望在接口内部使用，所以就增加了私有方法。</p>
<p>7.7 接口与抽象类之间的对比</p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220328002053452.png" alt="image-20220328002053452"></p>
<blockquote>
<p>在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。</p>
</blockquote>
<p>总结：</p>
<p>接口的使用</p>
<ol>
<li><p>接口的理解：接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。</p>
</li>
<li><p>定义接口的关键字：interface</p>
</li>
<li><p>接口内部结构的说明：</p>
<blockquote>
<p>可以声明：<br>属性：必须使用public static final修饰<br>方法：jdk8之前：声明抽象方法，修饰为public abstract<br>  jdk8:声明静态方法、默认方法<br>  jdk9:声明私有方法</p>
</blockquote>
<blockquote>
<p>不可以声明：构造器、代码块等</p>
</blockquote>
</li>
<li><p>接口与类的关系 ：实现关系</p>
</li>
<li><p>格式：class A extends SuperA implements B,C{}</p>
</li>
</ol>
<p>A相较于SuperA来讲，叫做子类<br>A相较于B,C来讲，叫做实现类。</p>
<ol start="6">
<li>满足此关系之后，说明：</li>
</ol>
<blockquote>
<p>类可以实现多个接口。<br>类针对于接口的多实现，一定程度上就弥补了类的单继承的局限性。<br>类必须将实现的接口中的所有的抽象方法都重写（或实现），方可实例化。否则，此实现类必须声明为抽象类。</p>
</blockquote>
<ol start="7">
<li><p>接口与接口的关系：继承关系，且可以多继承</p>
</li>
<li><p>接口的多态性： 接口名 变量名 &#x3D; new 实现类对象;</p>
</li>
<li><p>面试题：区分抽象类和接口</p>
</li>
</ol>
<blockquote>
<p>共性：都可以声明抽象方法<br>都不能实例化</p>
</blockquote>
<blockquote>
<p>不同：① 抽象类一定有构造器。接口没有构造器<br>② 类与类之间继承关系，类与接口之间是实现关系，接口与接口之间是多继承关系</p>
</blockquote>
<h3 id="8-内部类（InnerClass"><a href="#8-内部类（InnerClass" class="headerlink" title="8. 内部类（InnerClass)"></a>8. 内部类（InnerClass)</h3><p>8.1 概述</p>
<p>8.1.1 什么是内部类</p>
<p>将一个类A定义在另一个类B里面，里面的那个类A就称为<code>内部类（InnerClass）</code>，类B则称为<code>外部类（OuterClass）</code>。</p>
<p>8.1.2 为什么要声明内部类呢</p>
<p>具体来说，当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整的结构B又只为外部事物A提供服务，不在其他地方单独使用，那么整个内部的完整结构B最好使用内部类。</p>
<p>总的来说，遵循<code>高内聚、低耦合</code>的面向对象开发原则。</p>
<p>8.1.3 内部类的分类</p>
<p>根据内部类声明的位置（如同变量的分类），我们可以分为：</p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20221124223912529.png" alt="image-20221124223912529"></p>
<p>8.2 成员内部类</p>
<p>8.2.1 概述</p>
<p>如果成员内部类中不使用外部类的非静态成员，那么通常将内部类声明为静态内部类，否则声明为非静态内部类。</p>
<p><strong>语法格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 外部类&#123;</span><br><span class="line">    [其他修饰符] [<span class="keyword">static</span>] class 内部类&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>成员内部类的使用特征，概括来讲有如下两种角色：</strong></p>
<ul>
<li>成员内部类作为<code>类的成员的角色</code>：<ul>
<li>和外部类不同，Inner class还可以声明为private或protected；</li>
<li>可以调用外部类的结构。（注意：在静态内部类中不能使用外部类的非静态成员）</li>
<li>Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；</li>
</ul>
</li>
<li>成员内部类作为<code>类的角色</code>：<ul>
<li>可以在内部定义属性、方法、构造器等结构</li>
<li>可以继承自己的想要继承的父类，实现自己想要实现的父接口们，和外部类的父类和父接口无关</li>
<li>可以声明为abstract类 ，因此可以被其它的内部类继承</li>
<li>可以声明为final的，表示不能被继承</li>
<li>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</li>
</ul>
</li>
</ul>
<p>注意点：</p>
<ol start="2">
<li><p>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</p>
</li>
<li><p>成员内部类可以直接使用外部类的所有成员，包括私有的数据</p>
</li>
<li><p>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</p>
</li>
</ol>
<p>8.2.2 创建成员内部类对象</p>
<ul>
<li>实例化静态内部类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部类名.静态内部类名 变量 = 外部类名.静态内部类名();</span><br><span class="line">变量.非静态方法();</span><br></pre></td></tr></table></figure>

<ul>
<li>实例化非静态内部类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部类名 变量1 = new 外部类();</span><br><span class="line">外部类名.非静态内部类名 变量2 = 变量1.new 非静态内部类名();</span><br><span class="line">变量2.非静态方法();</span><br></pre></td></tr></table></figure>

<p>8.2.3 举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMemberInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建静态内部类实例，并调用方法</span></span><br><span class="line">        Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br><span class="line">        inner.inFun();</span><br><span class="line">        <span class="comment">//调用静态内部类静态方法</span></span><br><span class="line">        Outer.StaticInner.inMethod();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建非静态内部类实例（方式1），并调用方法</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">NoStaticInner</span> <span class="variable">inner1</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">NoStaticInner</span>();</span><br><span class="line">        inner1.inFun();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建非静态内部类实例（方式2）</span></span><br><span class="line">        Outer.<span class="type">NoStaticInner</span> <span class="variable">inner2</span> <span class="operator">=</span> outer.getNoStaticInner();</span><br><span class="line">        inner1.inFun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;外部类的静态a&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">b</span>  <span class="operator">=</span> <span class="string">&quot;外部类的静态b&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;外部类对象的非静态c&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;外部类对象的非静态d&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span><span class="string">&quot;静态内部类的静态a&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;静态内部类对象的非静态c&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.a = &quot;</span> + Outer.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inFun</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.inFun&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.a = &quot;</span> + Outer.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">            System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line"><span class="comment">//            System.out.println(&quot;d = &quot; + d);//不能访问外部类的非静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NoStaticInner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;非静态内部类对象的非静态a&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;非静态内部类对象的非静态c&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inFun</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NoStaticInner.inFun&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.a = &quot;</span> + Outer.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.c = &quot;</span> + Outer.<span class="built_in">this</span>.c);</span><br><span class="line">            System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">            System.out.println(<span class="string">&quot;d = &quot;</span> + d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NoStaticInner <span class="title function_">getNoStaticInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NoStaticInner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.3 局部内部类</p>
<p>8.3.1 非匿名局部内部类</p>
<p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 外部类&#123;</span><br><span class="line">    [修饰符] 返回值类型  方法名(形参列表)&#123;</span><br><span class="line">            [<span class="keyword">final</span>/<span class="keyword">abstract</span>] class 内部类&#123;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译后有自己的独立的字节码文件，只不过在内部类名前面冠以外部类名、$符号、编号。<ul>
<li>这里有编号是因为同一个外部类中，不同的方法中存在相同名称的局部内部类</li>
</ul>
</li>
</ul>
<ul>
<li>和成员内部类不同的是，它前面不能有权限修饰符等</li>
<li>局部内部类如同局部变量一样，有作用域</li>
<li>局部内部类中是否能访问外部类的非静态的成员，取决于所在的方法</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: TestLocalInner</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span> 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLocalInner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.outMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        out.outTest();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runner</span> <span class="variable">runner</span> <span class="operator">=</span> Outer.getRunner();</span><br><span class="line">        runner.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer.outMethod&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;局部变量c&quot;</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inMethod</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inner.inMethod&quot;</span>);</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.inMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inMethod1</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inner.inMethod1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.inMethod1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runner <span class="title function_">getRunner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalRunner</span> <span class="keyword">implements</span> <span class="title class_">Runner</span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;LocalRunner.run&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalRunner</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Runner</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.3.2 匿名内部类</p>
<p>因为考虑到这个子类或实现类是一次性的，那么我们“费尽心机”的给它取名字，就显得多余。那么我们完全可以使用匿名内部类的方式来实现，避免给类命名的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类([实参列表])&#123;</span><br><span class="line">    重写方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父接口()&#123;</span><br><span class="line">    重写方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例1：使用匿名内部类的对象直接调用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	<span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例2：通过父类或父接口的变量多态引用匿名内部类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	<span class="type">A</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;;</span><br><span class="line">    	obj.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例3：匿名内部类的对象作为实参</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(A a)</span>&#123;</span><br><span class="line">    	a.method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	test(<span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>类的成员之五：内部类</p>
<ol>
<li><p>什么是内部类？<br>将一个类A定义在另一个类B里面，里面的那个类A就称为<code>内部类（InnerClass）</code>，类B则称为<code>外部类（OuterClass）</code>。</p>
</li>
<li><p>为什么需要内部类？<br>具体来说，当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整的结构B又只为外部事物A<br>提供服务，不在其他地方单独使用，那么整个内部的完整结构B最好使用内部类。</p>
</li>
</ol>
<p>总的来说，遵循<code>高内聚、低耦合</code>的面向对象开发原则。</p>
<ol start="3">
<li><p>内部类使用举例：<br>Thread类内部声明了State类，表示线程的生命周期<br>HashMap类中声明了Node类，表示封装的key和value</p>
</li>
<li><p>内部类的分类：（参考变量的分类）</p>
<blockquote>
<p>成员内部类：直接声明在外部类的里面。<br>使用static修饰的：静态的成员内部类<br>不使用static修饰的：非静态的成员内部类</p>
</blockquote>
<blockquote>
<p>局部内部类：声明在方法内、构造器内、代码块内的内部类<br>匿名的局部内部类<br>非匿名的局部内部类</p>
</blockquote>
</li>
<li><p>内部类这节要讲的知识：</p>
</li>
</ol>
<blockquote>
<p>成员内部类的理解<br>如何创建成员内部类的实例<br>如何在成员内部类中调用外部类的结构<br>局部内部类的基本使用</p>
</blockquote>
<ol start="6">
<li><p>关于成员内部类的理解：</p>
<blockquote>
<p>从类的角度看：</p>
<ul>
<li>内部可以声明属性、方法、构造器、代码块、内部类等结构</li>
<li>此内部类可以声明父类，可以实现接口</li>
<li>可以使用final修饰</li>
<li>可以使用abstract修饰</li>
</ul>
</blockquote>
<blockquote>
<p>从外部类的成员的角度看：</p>
<ul>
<li>在内部可以调用外部类的结构。比如：属性、方法等</li>
<li>除了使用public、缺省权限修饰之外，还可以使用private、protected修饰</li>
<li>可以使用static修饰</li>
</ul>
</blockquote>
</li>
<li><p>关于局部内部类的说明：</p>
</li>
</ol>
<h3 id="9-枚举类"><a href="#9-枚举类" class="headerlink" title="9. 枚举类"></a>9. 枚举类</h3><p>9.1 概述</p>
<ul>
<li><p>枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。</p>
</li>
<li><p>枚举类的例子举不胜举：</p>
<ul>
<li><code>星期</code>：Monday(星期一)……Sunday(星期天)</li>
<li><code>性别</code>：Man(男)、Woman(女)</li>
<li><code>月份</code>：January(1月)……December(12月)</li>
<li><code>季节</code>：Spring(春节)……Winter(冬天)</li>
<li><code>三原色</code>：red(红色)、green(绿色)、blue(蓝色)</li>
<li><code>支付方式</code>：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)</li>
<li><code>就职状态</code>：Busy(忙碌)、Free(空闲)、Vocation(休假)、Dimission(离职)</li>
<li><code>订单状态</code>：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Checked（已确认收货）、Return（退货）、Exchange（换货）、Cancel（取消）</li>
<li><code>线程状态</code>：创建、就绪、运行、阻塞、死亡</li>
</ul>
</li>
<li><p><strong>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。</strong></p>
</li>
<li><p>枚举类的实现：</p>
<ul>
<li>在JDK5.0 之前，需要程序员自定义枚举类型。</li>
<li>在JDK5.0 之后，Java支持<code>enum</code>关键字来快速定义枚举类型。</li>
</ul>
</li>
</ul>
<p>9.2 定义枚举类（JDK5.0 之前）</p>
<p>在JDK5.0 之前如何声明枚举类呢？</p>
<ul>
<li><code>私有化</code>类的构造器，保证不能在类的外部创建其对象</li>
<li>在类的内部创建枚举类的实例。声明为：<code>public static final</code> ，对外暴露这些常量对象</li>
<li>对象如果有<code>实例变量</code>，应该声明为<code>private final</code>（建议，不是必须），并在构造器中初始化</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;<span class="comment">//季节的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;<span class="comment">//季节的描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SEASONNAME = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.SEASONDESC = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;SEASONNAME=&#x27;&quot;</span> + SEASONNAME + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, SEASONDESC=&#x27;&quot;</span> + SEASONDESC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeasonTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9.3 定义枚举类（JDK5.0 之后）</p>
<p>9.3.1 enum关键字声明枚举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    常量对象列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    常量对象列表;</span><br><span class="line">    </span><br><span class="line">    对象的实例变量列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">		System.out.println(spring);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9.3.2 enum方式定义的要求和特点</p>
<ul>
<li>枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写。</li>
<li>列出的实例系统会自动添加 public static final 修饰。</li>
<li>如果常量对象列表后面没有其他代码，那么“；”可以省略，否则不可以省略“；”。</li>
<li>编译器给枚举类默认提供的是private的无参构造，如果枚举类需要的是无参构造，就不需要声明，写常量对象列表时也不用加参数</li>
<li>如果枚举类需要的是有参构造，需要手动定义，有参构造的private可以省略，调用有参构造的方法就是在常量对象名后面加(实参列表)就可以。</li>
<li>枚举类默认继承的是java.lang.Enum类，因此不能再继承其他的类型。</li>
<li>JDK5.0 之后switch，提供支持枚举类型，case后面可以写枚举常量名，无需添加枚举类作为限定。</li>
</ul>
<p>举例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    MONDAY(<span class="string">&quot;星期一&quot;</span>),</span><br><span class="line">    TUESDAY(<span class="string">&quot;星期二&quot;</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">&quot;星期三&quot;</span>),</span><br><span class="line">    THURSDAY(<span class="string">&quot;星期四&quot;</span>),</span><br><span class="line">    FRIDAY(<span class="string">&quot;星期五&quot;</span>),</span><br><span class="line">    SATURDAY(<span class="string">&quot;星期六&quot;</span>),</span><br><span class="line">    SUNDAY(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Week</span><span class="params">(String description)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() +<span class="string">&quot;:&quot;</span>+ description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWeek</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Week</span> <span class="variable">week</span> <span class="operator">=</span> Week.MONDAY;</span><br><span class="line">        System.out.println(week);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (week)&#123;</span><br><span class="line">            <span class="keyword">case</span> MONDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;怀念周末，困意很浓&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TUESDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;进入学习状态&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;死撑&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> THURSDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;小放松&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRIDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;又信心满满&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SATURDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;开始盼周末，无心学习&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUNDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;一觉到下午&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>经验之谈：</p>
<p>开发中，当需要定义一组常量时，强烈建议使用枚举类。</p>
</blockquote>
<p>9.4 enum中常用方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！</span><br><span class="line">    </span><br><span class="line">static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法</span><br><span class="line">    </span><br><span class="line">static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</span><br><span class="line">    </span><br><span class="line">String name():得到当前枚举常量的名称。建议优先使用toString()。</span><br><span class="line">    </span><br><span class="line">int ordinal():返回当前枚举常量的次序号，默认从0开始</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEnumMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//values()</span></span><br><span class="line">        Week[] values = Week.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="comment">//ordinal()、name()</span></span><br><span class="line">            System.out.println((values[i].ordinal()+<span class="number">1</span>) + <span class="string">&quot;-&gt;&quot;</span> + values[i].name());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入星期值：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">weekValue</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="type">Week</span> <span class="variable">week</span> <span class="operator">=</span> values[weekValue-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//toString()</span></span><br><span class="line">        System.out.println(week);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入星期名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">weekName</span> <span class="operator">=</span> input.next();</span><br><span class="line">        <span class="comment">//valueOf()</span></span><br><span class="line">        week = Week.valueOf(weekName);</span><br><span class="line">        System.out.println(week);</span><br><span class="line"></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9.5 实现接口的枚举类</p>
<ul>
<li>和普通 Java 类一样，枚举类可以实现一个或多个接口</li>
<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li>
<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li>
</ul>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、枚举类可以像普通的类一样，实现接口，并且可以多个，但要求必须实现里面所有的抽象方法！</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> implements 接口<span class="number">1</span>，接口<span class="number">2</span>&#123;</span><br><span class="line">	<span class="comment">//抽象方法的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、如果枚举类的常量可以继续重写抽象方法!</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> implements 接口<span class="number">1</span>，接口<span class="number">2</span>&#123;</span><br><span class="line">    常量名<span class="number">1</span>(参数)&#123;</span><br><span class="line">        <span class="comment">//抽象方法的实现或重写</span></span><br><span class="line">    &#125;,</span><br><span class="line">    常量名<span class="number">2</span>(参数)&#123;</span><br><span class="line">        <span class="comment">//抽象方法的实现或重写</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字定义枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">	<span class="comment">//1. 创建枚举类中的对象,声明在enum枚举类的首位</span></span><br><span class="line">	SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;宁静的夏天&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;秋天是用来分手的季节&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;白雪皑皑&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;2002年的第一场雪&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 声明每个对象拥有的属性:private final修饰</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String SEASON_NAME;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String SEASON_DESC;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 私有化类的构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.SEASON_NAME = seasonName;</span><br><span class="line">		<span class="built_in">this</span>.SEASON_DESC = seasonDesc;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSEASON_NAME</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SEASON_NAME;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSEASON_DESC</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SEASON_DESC;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>枚举类的使用</p>
<ol>
<li><p>枚举类的理解：<br>枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。</p>
</li>
<li><p>举例：</p>
</li>
</ol>
<ul>
<li><code>星期</code>：Monday(星期一)……Sunday(星期天)</li>
<li><code>性别</code>：Man(男)、Woman(女)</li>
<li><code>月份</code>：January(1月)……December(12月)</li>
<li><code>季节</code>：Spring(春节)……Winter(冬天)</li>
<li><code>三原色</code>：red(红色)、green(绿色)、blue(蓝色)</li>
<li><code>支付方式</code>：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)</li>
<li><code>就职状态</code>：Busy(忙碌)、Free(空闲)、Vocation(休假)、Dimission(离职)</li>
<li><code>订单状态</code>：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Checked（已确认收货）、Return（退货）、Exchange（换货）、Cancel（取消）</li>
<li><code>线程状态</code>：创建、就绪、运行、阻塞、死亡</li>
</ul>
<ol start="3">
<li>开发中的建议：</li>
</ol>
<blockquote>
<p>开发中，如果针对于某个类，其实例是确定个数的。则推荐将此类声明为枚举类。<br>如果枚举类的实例只有一个，则可以看做是单例的实现方式。</p>
</blockquote>
<ol start="4">
<li><p>JDK5.0 之前如何自定义枚举类 （了解）<br>见代码</p>
</li>
<li><p>JDK5.0中使用enum定义枚举类<br>见代码</p>
</li>
<li><p>Enum中的常用方法:<br>6.1 使用enum关键字定义的枚举类，默认其父类是java.lang.Enum类<br> 使用enum关键字定义的枚举类，不要再显示的定义其父类。否则报错。<br>6.2 熟悉Enum类中常用的方法<br> String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！<br> (关注)static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法<br> (关注)static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。<br> String name():得到当前枚举常量的名称。建议优先使用toString()。<br> int ordinal():返回当前枚举常量的次序号，默认从0开始</p>
</li>
<li><p>枚举类实现接口的操作<br>情况1：枚举类实现接口，在枚举类中重写接口中的抽象方法。当通过不同的枚举类对象调用此方法时，执行的是同一个方法。<br>情况2：让枚举类的每一个对象重写接口中的抽象方法。当通过不同的枚举类对象调用此方法时，执行的是不同的实现的方法。</p>
</li>
</ol>
<h3 id="10-注解-Annotation"><a href="#10-注解-Annotation" class="headerlink" title="10. 注解(Annotation)"></a>10. 注解(Annotation)</h3><p>10.1 注解概述</p>
<p>10.1.1 什么是注解</p>
<p>注解（Annotation）是从<code>JDK5.0</code>开始引入，以“<code>@注解名</code>”在代码中存在。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(value=”unchecked”)</span></span><br></pre></td></tr></table></figure>

<p>Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “name&#x3D;value” 对中。</p>
<p>注解可以在类编译、运行时进行加载，体现不同的功能。</p>
<p>10.1.2 注解与注释</p>
<p>注解也可以看做是一种注释，通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。但是，注解，不同于单行注释和多行注释。</p>
<ul>
<li>对于单行注释和多行注释是给程序员看的。</li>
<li>而注解是可以被编译器或其他程序读取的。程序还可以根据注解的不同，做出相应的处理。</li>
</ul>
<p>10.1.3 注解的重要性</p>
<p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在<code>JavaEE/Android中注解占据了更重要的角色</code>，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的<code>繁冗代码</code>和<code>XML配置</code>等。</p>
<p>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，Struts2有一部分也是基于注解的了。<code>注解是一种趋势</code>，一定程度上可以说：<code>框架 = 注解 + 反射 + 设计模式</code>。</p>
<p>10.2 常见的Annotation作用</p>
<p><strong>示例1：生成文档相关的注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@author</span> 标明开发该类模块的作者，多个作者之间使用,分割</span><br><span class="line"><span class="meta">@version</span> 标明该类模块的版本</span><br><span class="line"><span class="meta">@see</span> 参考转向，也就是相关主题</span><br><span class="line"><span class="meta">@since</span> 从哪个版本开始增加的</span><br><span class="line"><span class="meta">@param</span> 对方法中某参数的说明，如果没有参数就不能写</span><br><span class="line"><span class="meta">@return</span> 对方法返回值的说明，如果方法的返回值类型是<span class="keyword">void</span>就不能写</span><br><span class="line"><span class="meta">@exception</span> 对方法可能抛出的异常进行说明 ，如果方法没有用<span class="keyword">throws</span>显式抛出的异常就不能写</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.annotation.javadoc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Math.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavadocTest</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 程序的主方法，程序的入口</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args String[] 命令行参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 求圆面积的方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> radius double 半径值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> double 圆的面积</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例2：在编译时进行格式检查(JDK内置的三个基本注解)</strong></p>
<p><code>@Override</code>: 限定重写父类方法，该注解只能用于方法</p>
<p><code>@Deprecated</code>: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</p>
<p><code>@SuppressWarnings</code>: 抑制编译器警告</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.annotation.javadoc;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;过时的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;重写的toString方法()&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例3：跟踪代码依赖性，实现替代配置文件功能</strong></p>
<ul>
<li>Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.servlet.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Spring框架中关于“事务”的管理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(String username, String isbn)</span> &#123;</span><br><span class="line">	<span class="comment">//1.查询书的单价</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line">    <span class="comment">//2. 更新库存</span></span><br><span class="line">    bookShopDao.updateBookStock(isbn);	</span><br><span class="line">    <span class="comment">//3. 更新用户的余额</span></span><br><span class="line">    bookShopDao.updateUserAccount(username, price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;dataSourceTransactionManager&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置每个方法使用的事务属性 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;buyBook&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span> </span></span><br><span class="line"><span class="tag">	 <span class="attr">isolation</span>=<span class="string">&quot;READ_COMMITTED&quot;</span>  <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>  <span class="attr">timeout</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>10.3 三个最基本的注解</p>
<p>10.3.1 @Override</p>
<ul>
<li><p>用于检测被标记的方法为有效的重写方法，如果不是，则报编译错误！</p>
</li>
<li><p>只能标记在方法上。</p>
</li>
<li><p>它会被编译器程序读取。</p>
</li>
</ul>
<p>10.3.2 @Deprecated</p>
<ul>
<li><p>用于表示被标记的数据已经过时，不推荐使用。</p>
</li>
<li><p>可以用于修饰 属性、方法、构造、类、包、局部变量、参数。</p>
</li>
<li><p>它会被编译器程序读取。</p>
</li>
</ul>
<p>10.3.3 @SuppressWarnings</p>
<ul>
<li><p>抑制编译警告。当我们不希望看到警告信息的时候，可以使用 SuppressWarnings 注解来抑制警告信息</p>
</li>
<li><p>可以用于修饰类、属性、方法、构造、局部变量、参数</p>
</li>
<li><p>它会被编译器程序读取。</p>
</li>
<li><p>可以指定的警告类型有（了解）</p>
<ul>
<li>all，抑制所有警告</li>
<li>unchecked，抑制与未检查的作业相关的警告</li>
<li>unused，抑制与未用的程式码及停用的程式码相关的警告</li>
<li>deprecation，抑制与淘汰的相关警告</li>
<li>nls，抑制与非 nls 字串文字相关的警告</li>
<li>null，抑制与空值分析相关的警告</li>
<li>rawtypes，抑制与使用 raw 类型相关的警告</li>
<li>static-access，抑制与静态存取不正确相关的警告</li>
<li>static-method，抑制与可能宣告为 static 的方法相关的警告</li>
<li>super，抑制与置换方法相关但不含 super 呼叫的警告</li>
<li>…</li>
</ul>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnnotation</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        f.show();</span><br><span class="line">        f.methodOl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodOl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="comment">/*	@Override</span></span><br><span class="line"><span class="comment">	void method01() &#123;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;Son Method&quot;);</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.4 元注解</p>
<p>JDK1.5在java.lang.annotation包定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。</p>
<p>（1）**@Target：**用于描述注解的使用范围</p>
<ul>
<li>可以通过枚举类型ElementType的10个常量对象来指定</li>
<li>TYPE，METHOD，CONSTRUCTOR，PACKAGE…..</li>
</ul>
<p>（2）**@Retention：**用于描述注解的生命周期</p>
<ul>
<li>可以通过枚举类型RetentionPolicy的3个常量对象来指定</li>
<li>SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）</li>
<li><code>唯有RUNTIME阶段才能被反射读取到</code>。</li>
</ul>
<p>（3）**@Documented**：表明这个注解应该被 javadoc工具记录。</p>
<p>（4）**@Inherited：**允许子类继承父类中的注解</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>拓展：元数据</p>
<p>String name &#x3D; “Tom”;</p>
</blockquote>
<p>10.5 自定义注解的使用</p>
<p>一个完整的注解应该包含三个部分：<br>（1）声明<br>（2）使用<br>（3）读取</p>
<p>10.5.1 声明自定义注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【元注解】</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    【成员列表】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义注解可以通过四个元注解@Retention,@Target，@Inherited,@Documented，分别说明它的声明周期，使用位置，是否被继承，是否被生成到API文档中。</li>
<li>Annotation 的成员在 Annotation 定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组</li>
<li>可以使用 default 关键字为抽象方法指定默认返回值</li>
<li>如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是“方法名 &#x3D; 返回值”，如果只有一个抽象方法需要赋值，且方法名为value，可以省略“value&#x3D;”，所以如果注解只有一个抽象方法成员，建议使用方法名value。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    String <span class="title function_">columnName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">columnType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.5.2 使用自定义注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.annotation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Table(&quot;t_stu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Column(columnName = &quot;sid&quot;,columnType = &quot;int&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@Column(columnName = &quot;sname&quot;,columnType = &quot;varchar(20)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>10.5.3 读取和处理自定义注解</p>
<p>自定义注解必须配上注解的信息处理流程才有意义。</p>
<p>我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。</p>
<p>具体的使用见<code>《尚硅谷_宋红康_第17章_反射机制.md》</code>。</p>
<p>10.6 JUnit单元测试</p>
<p>10.6.1 测试分类</p>
<p><strong>黑盒测试：</strong>不需要写代码，给输入值，看程序是否能够输出期望的值。 </p>
<p><strong>白盒测试：</strong>需要写代码的。关注程序具体的执行流程。</p>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220511181800694.png" alt="image-20220511181800694" style="zoom: 50%;" />

<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220524102038600.png" alt="image-20220524102038600"></p>
<p>10.6.2 JUnit单元测试介绍</p>
<p>JUnit 是由 Erich Gamma 和 Kent Beck 编写的一个测试框架（regression testing framework），供Java开发人员编写单元测试之用。</p>
<p><strong>JUnit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。</strong></p>
<p>要使用JUnit，必须在项目的编译路径中<code>引入JUnit的库</code>，即相关的.class文件组成的jar包。jar就是一个压缩包，压缩包都是开发好的第三方（Oracle公司第一方，我们自己第二方，其他都是第三方）工具类，都是以class文件形式存在的。</p>
<p>10.6.3 引入本地JUnit.jar</p>
<p>第1步：在项目中File-Project Structure中操作：添加Libraries库</p>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20211228180938922.png" alt="image-20211228180938922" style="zoom:80%;" />

<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20221002195547325.png" alt="image-20221002195547325"></p>
<p>其中，junit-libs包内容如下：</p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220813005206452.png" alt="image-20220813005206452"></p>
<p>第2步：选择要在哪些module中应用JUnit库</p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220813005511062.png" alt="image-20220813005511062"></p>
<p>第3步：检查是否应用成功</p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220813005729233.png" alt="image-20220813005729233"></p>
<p><strong>注意Scope：选择Compile，否则编译时，无法使用JUnit。</strong></p>
<p>第4步：下次如果有新的模块要使用该libs库，这样操作即可</p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220813005944022.png" alt="image-20220813005944022"></p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220813010018152.png" alt="image-20220813010018152"></p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220813010055217.png" alt="image-20220813010055217"></p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220813010124381.png" alt="image-20220813010124381"></p>
<p>10.6.4 编写和运行@Test单元测试方法</p>
<p>JUnit4版本，要求@Test标记的方法必须满足如下要求：</p>
<ul>
<li>所在的类必须是public的，非抽象的，包含唯一的无参构造器。</li>
<li>@Test标记的方法本身必须是public，非抽象的，非静态的，void无返回值，()无参数的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.junit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJUnit</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestJUnit.test01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestJUnit.test02&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestJUnit.test03&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220106152412245.png" alt="image-20220106152412245"></p>
<p>10.6.5 设置执行JUnit用例时支持控制台输入</p>
<p><strong>1. 设置数据：</strong></p>
<p>默认情况下，在单元测试方法中使用Scanner时，并不能实现控制台数据的输入。需要做如下设置：</p>
<p>在<code>idea64.exe.vmoptions配置文件</code>中加入下面一行设置，重启idea后生效。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">-Deditable.java.test.console</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 配置文件位置：</strong></p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220813011625546.png" alt="image-20220813011625546"></p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220813011642180.png" alt="image-20220813011642180"></p>
<p>添加完成之后，重启IDEA即可。</p>
<p><strong>3. 如果上述位置设置不成功，需要继续修改如下位置</strong></p>
<p>修改位置1：IDEA安装目录的bin目录（例如：<code>D:\develop_tools\IDEA\IntelliJ IDEA 2022.1.2\bin</code>）下的idea64.exe.vmoptions文件。 </p>
<p>修改位置2：C盘的用户目录<code>C:\Users\用户名\AppData\Roaming\JetBrains\IntelliJIdea2022.1</code> 下的idea64.exe.vmoptions&#96;件。</p>
<p>10.6.6 定义test测试方法模板</p>
<p>选中自定义的模板组，点击”+”（1.Live Template）来定义模板。</p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20211229100040505.png" alt="image-20211229100040505"></p>
<p>总结：</p>
<p>注解的使用</p>
<ol>
<li>Annotation的理解</li>
</ol>
<blockquote>
<p>注解（Annotation）是从<code>JDK5.0</code>开始引入，以“<code>@注解名</code>”在代码中存在。<br>Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。<br>还可以添加一些参数值，这些信息被保存在 Annotation 的 “name&#x3D;value” 对中。<br>注解可以在类编译、运行时进行加载，体现不同的功能。</p>
</blockquote>
<ol start="2">
<li><p>注解的应用场景：<br>示例1：生成文档相关的注解<br>示例2：在编译时进行格式检查(JDK内置的三个基本注解)<br>示例3：跟踪代码依赖性，实现替代配置文件功能</p>
</li>
<li><p>Java基础涉及到的三个常用注解<br><code>@Override</code>: 限定重写父类方法，该注解只能用于方法<br><code>@Deprecated</code>: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择<br><code>@SuppressWarnings</code>: 抑制编译器警告</p>
</li>
<li><p>自定义注解<br>以@SuppressWarnings为参照，进行定义即可。</p>
</li>
<li><p>元注解的理解：<br>元注解：对现有的注解进行解释说明的注解。</p>
</li>
</ol>
<p>讲4个元注解：<br>（1）@Target：用于描述注解的使用范围<br>可以通过枚举类型ElementType的10个常量对象来指定<br>TYPE，METHOD，CONSTRUCTOR，PACKAGE…..</p>
<p>（2）@Retention：用于描述注解的生命周期<br>可以通过枚举类型RetentionPolicy的3个常量对象来指定<br>SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）<br>唯有RUNTIME阶段才能被反射读取到。</p>
<p>（3）@Documented：表明这个注解应该被 javadoc工具记录。<br>（4）@Inherited：允许子类继承父类中的注解</p>
<p>拓展： 元数据。<br>String name &#x3D; “Tom”;</p>
<p>框架 &#x3D; 注解 + 反射 + 设计模式</p>
<h3 id="11-包装类"><a href="#11-包装类" class="headerlink" title="11. 包装类"></a>11. 包装类</h3><p>11.1 为什么需要包装类</p>
<p>Java提供了两个类型系统，<code>基本数据类型</code>与<code>引用数据类型</code>。使用基本数据类型在于效率，然而当要使用只针对对象设计的API或新特性（例如泛型），怎么办呢？例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况1：方法形参</span></span><br><span class="line">Object类的equals(Object obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2：方法形参</span></span><br><span class="line">ArrayList类的add(Object obj)</span><br><span class="line"><span class="comment">//没有如下的方法：</span></span><br><span class="line">add(<span class="type">int</span> number)</span><br><span class="line">add(<span class="type">double</span> d)</span><br><span class="line">add(<span class="type">boolean</span> b)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况3：泛型</span></span><br><span class="line">Set&lt;T&gt;</span><br><span class="line">List&lt;T&gt;</span><br><span class="line">Cllection&lt;T&gt;</span><br><span class="line">Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<p>11.2 有哪些包装类</p>
<p>Java针对八种基本数据类型定义了相应的引用类型：包装类（封装类）。有了类的特点，就可以调用类中的方法，Java才是真正的面向对象。</p>
<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220329001912486.png" alt="image-20220329001912486" style="zoom:80%;" />

<p>封装以后的，内存结构对比：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">520</span>;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">520</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220514163725830.png" alt="image-20220514163725830" style="zoom:80%;" />

<p>11.3 自定义包装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInteger</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInteger</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>11.4 包装类与基本数据类型间的转换</p>
<p>11.4.1 装箱</p>
<p> <strong>装箱：把基本数据类型转为包装类对象</strong></p>
<blockquote>
<p>转为包装类的对象，是为了使用专门为对象设计的API和特性</p>
</blockquote>
<p>基本数值—-&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line"><span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(“<span class="number">4.56</span>”);</span><br><span class="line"><span class="type">Long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Long</span>(“asdf”);  <span class="comment">//NumberFormatException</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">obj2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure>

<p>11.4.2 拆箱</p>
<p><strong>拆箱：把包装类对象拆为基本数据类型</strong></p>
<blockquote>
<p>转为基本数据类型，一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的。比较、算术等</p>
</blockquote>
<p>包装对象—-&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> obj.intValue();</span><br></pre></td></tr></table></figure>

<p><strong>自动装箱与拆箱：</strong></p>
<p>由于我们经常要做基本类型与包装类之间的转换，从<code>JDK5.0 </code>开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//错误的，1是int类型</span></span><br></pre></td></tr></table></figure>

<p>11.5 基本数据类型、包装类与字符串间的转换</p>
<p><strong>（1）基本数据类型转为字符串</strong></p>
<p><strong>方式1：</strong>调用字符串重载的valueOf()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//String str = a;//错误的</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(a);</span><br></pre></td></tr></table></figure>

<p><strong>方式2：</strong>更直接的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> a + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>（2）字符串转为基本数据类型</strong></p>
<p><strong>方式1：</strong>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型，例如：</p>
<ul>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
</ul>
<p><strong>方式2：</strong>字符串转为包装类，然后可以自动拆箱为基本数据类型</p>
<ul>
<li><code>public static Integer valueOf(String s)</code>：将字符串参数转换为对应的Integer包装类，然后可以自动拆箱为int基本类型</li>
<li><code>public static Long valueOf(String s)</code>：将字符串参数转换为对应的Long包装类，然后可以自动拆箱为long基本类型</li>
<li><code>public static Double valueOf(String s)</code>：将字符串参数转换为对应的Double包装类，然后可以自动拆箱为double基本类型</li>
</ul>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
<p><strong>方式3：</strong>通过包装类的构造器实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;整数的字符串&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;小数的字符串&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true或false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;整数的字符串&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.valueOf(<span class="string">&quot;小数的字符串&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.valueOf(<span class="string">&quot;true或false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(“<span class="number">12</span>”);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其他方式小结：</p>
<p><img src="D:/Java入门教程/01_课件与电子教材/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220813012801907.png" alt="image-20220813012801907"></p>
<p>11.6 包装类的其它API</p>
<p>11.6.1 数据类型的最大最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.MAX_VALUE和Integer.MIN_VALUE</span><br><span class="line">    </span><br><span class="line">Long.MAX_VALUE和Long.MIN_VALUE</span><br><span class="line">    </span><br><span class="line">Double.MAX_VALUE和Double.MIN_VALUE</span><br></pre></td></tr></table></figure>

<p>11.6.2 字符转大小写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character.toUpperCase(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Character.toLowerCase(<span class="string">&#x27;X&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>11.6.3 整数转进制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="type">int</span> i) </span><br><span class="line">    </span><br><span class="line">Integer.toHexString(<span class="type">int</span> i)</span><br><span class="line">    </span><br><span class="line">Integer.toOctalString(<span class="type">int</span> i)</span><br></pre></td></tr></table></figure>

<p>11.6.4 比较的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double.compare(<span class="type">double</span> d1, <span class="type">double</span> d2)</span><br><span class="line">    </span><br><span class="line">Integer.compare(<span class="type">int</span> x, <span class="type">int</span> y) </span><br></pre></td></tr></table></figure>

<p>11.7 包装类对象的特点</p>
<p>11.7.1 包装类缓存对象</p>
<table>
<thead>
<tr>
<th>包装类</th>
<th>缓存对象</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>-128~127</td>
</tr>
<tr>
<td>Short</td>
<td>-128~127</td>
</tr>
<tr>
<td>Integer</td>
<td>-128~127</td>
</tr>
<tr>
<td>Long</td>
<td>-128~127</td>
</tr>
<tr>
<td>Float</td>
<td>没有</td>
</tr>
<tr>
<td>Double</td>
<td>没有</td>
</tr>
<tr>
<td>Character</td>
<td>0~127</td>
</tr>
<tr>
<td>Boolean</td>
<td>true和false</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//这个用的是缓冲的常量对象，在方法区</span></span><br><span class="line">System.out.println(m == n);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);<span class="comment">//另一个新new的在堆中</span></span><br><span class="line">System.out.println(x == y);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">System.out.println(d1==d2);<span class="comment">//false 比较地址，没有缓存对象，每一个都是新new的</span></span><br></pre></td></tr></table></figure>

<p>11.7.2 类型转换问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(i==j);<span class="comment">//true  会先将i自动拆箱为int，然后根据基本数据类型“自动类型转换”规则，转为double比较</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(i==j);<span class="comment">//true 会自动拆箱，按照基本数据类型进行比较</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.0</span></span><br><span class="line">System.out.println(i==d);<span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure>

<p>11.7.3 包装类对象不可变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExam</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="type">Circle</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">		change(i,j,c);</span><br><span class="line">		System.out.println(<span class="string">&quot;i = &quot;</span> + i);<span class="comment">//1</span></span><br><span class="line">		System.out.println(<span class="string">&quot;j = &quot;</span> + j);<span class="comment">//2</span></span><br><span class="line">		System.out.println(<span class="string">&quot;c.radius = &quot;</span> + c.radius);<span class="comment">//10.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 方法的参数传递机制：</span></span><br><span class="line"><span class="comment">	 * （1）基本数据类型：形参的修改完全不影响实参</span></span><br><span class="line"><span class="comment">	 * （2）引用数据类型：通过形参修改对象的属性值，会影响实参的属性值</span></span><br><span class="line"><span class="comment">	 * 这类Integer等包装类对象是“不可变”对象，即一旦修改，就是新对象，和实参就无关了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a ,Integer b,Circle c )</span>&#123;</span><br><span class="line">		a += <span class="number">10</span>;</span><br><span class="line"><span class="comment">//		b += 10;//等价于  b = new Integer(b+10);</span></span><br><span class="line">		c.radius += <span class="number">10</span>;</span><br><span class="line">		<span class="comment">/*c = new Circle();</span></span><br><span class="line"><span class="comment">		c.radius+=10;*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">	<span class="type">double</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>包装类的使用</p>
<ol>
<li><p>为什么要使用包装类？<br>为了使得基本数据类型的变量具备引用数据类型变量的相关特征（比如：封装性、继承性、多态性），我们给各个基本数据<br>类型的变量都提供了对应的包装类。</p>
</li>
<li><p>(掌握)基本数据类型对应的包装类类型<br>byte -&gt; Byte<br>short -&gt; Short<br>int -&gt; Integer<br>long -&gt; Long<br>float -&gt; Float<br>double -&gt;Double</p>
</li>
</ol>
<p>char -&gt; Character<br>boolean -&gt; Boolean</p>
<ol start="3">
<li><p>掌握基本数据类型 与 包装类之间的转换。<br>3.1 为什么需要转换</p>
<blockquote>
<p>一方面，在有些场景下，需要使用基本数据类型对应的包装类的对象。此时就需要将基本数据类型的变量转换为<br>包装类的对象。比如：ArrayList的add(Object obj);Object类的equals(Object obj)<br>对于包装类来讲，既然我们使用的是对象，那么对象是不能进行+ - * &#x2F;等运算的。为了能够进行这些运算，就<br>需要将包装类的对象转换为基本数据类型的变量。</p>
</blockquote>
<p>3.2 如何转换：<br> （装箱）基本数据类型 —&gt; 包装类：① 使用包装类的构造器 ② （建议）调用包装类的valueOf(xxx xx)<br> （拆箱）包装类 —&gt; 基本数据类型：调用包装类的xxxValue()<br> 注意：原来使用基本数据类型变量的位置，改成包装类以后，对于成员变量来说，其默认值变化了！</p>
<p> jdk5.0新特性：自动装箱、自动拆箱。</p>
</li>
<li><p>String 与 基本数据类型、包装类之间的转换。</p>
<p>基本数据类型、包装类 —&gt; String类型：① 调用String的重载的静态方法valueOf(xxx xx) ; ② 基本数据类型的变量 + “”</p>
<p>String类型 —&gt; 基本数据类型、包装类: 调用包装类的静态方法：parseXxx()</p>
</li>
</ol>
]]></content>
  </entry>
</search>
